리액트 수업

1. 개발환경 설정하기
Node.js(JavaScript runtime) , npm(node package manager) 설치하기
* npm은 프로젝트에서 필요로 하는 다양한 외부 라이브러리의 버전을 관리하고 편하게 설치 및 삭제할 수 있도록 도와주는 역할
* Node.js를 설치하면 npm은 자동으로 설치된다.

VSCode 사용



2. 리액스 소개
React: A JavaScript library for building user interfaces
사용자 인터페이스를 만들기 위한 JavaScript 라이브러리

라이브러리는 자주 사용되는 기능들을 정리해서 모아 놓은 것
+
사용자 인터페이스(User Interface, UI): 사용자와 컴퓨터 프로그램이 서로 상호작용을 하기 위해 중간에서 입력과 출력을 제어해주는 것
=> UI 라이브러리

리액트는 대표적은 JavaScript UI 라이브러리



3. 리액트 장점
- 빠른 업데이트와 렌더링 속도
	> Virtual DOM을 사용해 빠른 업데이트 속도를 제공한다. 
	> DOM은 웹페이지를 정의하는 오브젝트
	> 화면이 업데이트 된다는 것은 DOM이 수정된다는 말
	> Virtual DOM은 페이지에서 수정된 부분만을 찾아 빠르게 업데이트 해준다.
- Component-Based
	> 모든 페이지가 Component로 구성되어 있음
	> 레고 블록을 조립하듯 컴포넌트들을 모아 개발
	> 재사용성(Reusability) ↑
	   - 개발 기간이 단축됨
	   - 유지보수가 용이함(문제가 생긴 모듈만 재배포하면 됨)
- Meta의 오픈소스이므로 꾸준한 버전 업데이트가 이루어지고 발전해나가고 있다.
- 활발한 지식공유 & 커뮤니티
- React Native를 이용해 모바일 개발도 할 수 있다.
	


4. 리액트 단점
- 방대한 학습량
- 높은 상태관리 복잡도



5. 리액트로 웹사이트를 만들 때, create-react-app(cra)을 사용
- Node.js v14.0.0 이상
- npm v6.14.0 이상
- VSCode
- 사용법: npx create-react-app <your-project-name>
- 실제 사용 예제: npx create-react-app my-app
- 경로 변경(change directory): cd my-app
- 애플리케이션 실행: npm start > localhost:3000으로 웹페이지가 실행됨
- create-react-app 공식 링크 : https://reactjs.org/docs/create-a-new-react-app.html



6. jsx
A syntax extension to JavaScript: JavaScript의 확장 문법
JavaScript + XML/html
ex. const element = <h1>Hello, world!</h1>;
- jsx의 역할: 내부적으로 XML/html 코드를 작성하여도 최종적으로는 JavaScript로 변환해주는 역할
	React.createElement(
		type,
		[props],
		[...children]
	)
	> 리액트의 createElement() 함수가 그 역할을 한다

- 예제 1
	> jsx를 사용한 코드
	class Hello Extends Reacat.Component {
		render() {
			return <div>Hello {this.props.toWhat}</div>;
		}
	}
	ReactDOM.render(
		<Hello toWhat = "World"	/>
		document.getElementById('root');
	)
	> JavaScript와 html을 같이 사용한 jsx 코드로 짜여진 Hello라는 리액트 컴포넌트를 
	> ReactDOM의 render() 함수를 이용해 브라우저 화면에 렌더링 해줌 

	> jsx를 사용하지 않은 코드
	class Hello Extends Reacat.Component {
		render() {
			return React.createElement('div', null, `Hello ${this.props.toWhat}`);
		}
	}
	ReactDOM.render(
		React.createElement(Hello, { toWhat: 'World' }, null),
		document.getElementById('root');
	)

- 예제 2
	> jsx를 사용한 코드
	const element = (
		<h1 className="greeting">
			Hello, world!
		</h1>
	)

	> jsx를 사용하지 않은 코드
	const element = React.createElement(
		'h1',
		{ classname: 'greeting },
		'Hello, world!'
	)

	> 결과: React.createElement()의 결과로 아래와 같은 객체가 생성된다.
	> 리액트에서는 이 객체를 React element라고 부른다.
	const element = {
		type: 'h1',
		props: {
			classname: 'greeting',
			children: 'Hello, world!'
		}
	}

- 리액트에서 꼭 jsx를 사용해야 하는 것은 아니나, jsx를 사용하면 생산성과 가독성이 올라가기 때문에 권장됨
- jsx 장점: 1. 간결한 코드 / 2. 가독성 > 버그를 발견하기 쉬움 / 3. Infection Attacks 방어

- jsx 사용 방법: JavaScript + XML/html 이 섞인 형태이기 때문에 기본적으로 JS의 모든 문법이 지원됨
	> ...XML/html
	  {JavaScript 코드}
	  ...XML/html

	> 변수 사용
		const name = '소플';
		const element = <h1>안녕, {name}</h1>	<<<<
		ReactDOM.render(
			element,
			document.getElementById('root')
		)

	> 함수 사용
		function formatName(user) {
			return user.firstName + ' ' + user.lastName;
		}
		const user = {
			fristName: 'Inje',
			lastName: 'Lee'
		};
		const element = (
			<h1>
				Hello, {formatName(user)}	<<<<
			</h1>
		);
		ReactDOM.render(
			element,
			document.getElementById('root')
		);

	> html 태그 사이가 아닌 태그 속성(attribute)에 값을 넣고 싶을 때
		// 큰따옴표 사이에 문자열을 넣거나
		const element = <div tabIndex="0"></div>;
		// 중괄호 사이에 JavaScript 코드를 넣으면 됨!
		const element = <img src={user.avatarUrl}></img>;
	
	> jsx에서는 중괄호{} 사이에 무조건 JavaScript가 들어간다고 외워두면 좋다!

	> jsx를 이용하여 자식(children)을 정의하는 방법: html에서 작성하듯이 상위 태그가 하위 태그를 둘러싸면 자연스럽게 자식이 정의된다.
	  여기서 div 태그의 자식은 h1, h2 태그
		const element = (
			<div>
				<h1>안녕하세요</h1>	<<<<
				<h2>열심히 리액트를 공부해 봅시다!</h2>	<<<<
			</div>
		);



7. element: 어떤 물체를 구성하는 성분
   React Element: 리액트를 구성하는 성분 > Elements are the smallest building blocks of React apps
   element는 원래 DOM(웹페이지의 모든 구성 정보를 담고 있는 객체)에서 사용하던 용어
   개발자도구의 'Elements' 탭에서 볼 수 있는 element들은 DOM Elements이며, 우리가 브라우저 화면에서 실제로 볼 수 있는 html 요소를 나타낸다.

   JavaScript 개발 초창기에, 화면에 나타나는 내용을 기술하는 자바스크립트 객체가 필요했음
   그래서 처음에는 기술하다는 의미를 가진 Describe에서 파생된 Descriptor로 불림
   그러나 Descriptor가 최종적으로 나타나는 형태는 DOM Elements였기 때문에, DOM과의 통일성을 위해 element로 부르게 됨

   Virtual DOM의 element가 React Elements. 이것을 렌더링 하면 Browser DOM의 DOM Elements가 된다.
   결국 React Elements는 DOM Elements의 가상 표현이라고 볼 수 있다.
   또한 DOM Elements는 React Elements에 비해 많은 정보를 담고 있기 때문에 크고 무겁다.

   React Elements는 화면에서 보이는 것들을 기술하고, 이것을 바탕으로 우리에게 실제로 보이는 DOM Elements가 만들어진다.

   React Elements는 JavaScript 객체 형태로 존재

   > element의 실제 모습을 알아보자!
   > 버튼을 나타내기 위한 element
   > 1. element의 type에 html 태그 이름이 문자열로 들어가는 경우
    	{
			type: 'button',
			props: {
				className: 'bg-green',
				children: {
					type: 'b',
					props: {
						children: 'Hello, element!'
					}
				}
			}
		}
		- 이 코드처럼 type에 html 태그 이름이 문자열로 들어가는 경우, element는 해당 태그 이름을 가진 DOM 노드를 나타내고, props는 속성에 해당한다. 
		- 그리고 이 element가 실제로 렌더링이 된다면, 아래와 같은 DOM Elements가 된다.
		 <button class='bg-green'>
			<b>
				Hello, element!
			</b>
		</button>

	> 2. element의 type에 html 태그 이름이 문자열로 들어가지 않는 경우
		{
			type: Button,
			props: {
				color: 'green',
				children: 'Hello, element!'
			}
		}
		- 이 JavaScript 코드는 React의 Component Element를 나타낸 것으로, 일반적인 JavaScript 객체
		- 다만 방금 전에 나왔던 element와 한 가지 다른 점은 type에 문자열로 된 html 태그가 아닌 React Component의 이름이 들어갔다는 점
		- 이처럼 React Element는 JavaScirpt 객체 형태로 존재한다.
		- 그리고 이 객체를 만드는 역할을 하는 것이 앞에서 나왔던 createElement 함수이다.
		- 앞에서 createElement 함수를 호출할 때 3가지의 파라미터를 넣었는데,
		React.createElement{
			type,
			[props],
			[...children]
		}
		- 첫 번째 파라미터: type
			~ html 태그 이름이 문자열로 들어가거나 React Component가 들어간다.
			~ React Component는 최종적으로는 HTML 태그를 사용하게 되어있는데,
			~ 하나의 컴포넌트는 여러 개의 자식 컴포넌트를 포함할 수 있고 자식 컴포넌트를 분해해보면 결국 HTML 태그가 나온다.
		- 두 번째 파라미터: props
			~ 간단히 말해 element의 속성(attributes)이라고 할 수 있음
			~ attributes보다 좀 더 상위의 개념이지만 element의 속성이라고 이해하고 나중에 더 자세하게 배울 예정
		- 세번째 파라미터: childeren
			~ 해당 엘리먼트의 자식 엘리먼트들이 이 부분에 들어가게 된다. 

	> 3. createElement 함수가 동작하는 과정
		- 이 예제에는 Button 컴포넌트와 ConfirmDialog 컴포넌트가 있으며,
		- confirmDialog 컴포넌트가 button 컴포넌트를 포함하고 있다.
		function Button(props) {
			return (
				<button classname={`bg-${props.color}`}>
					<b>
						{props.children}
					</b>
				</button>
			);
		}

		function ConfirmDialog(props) {
			return (
				<div>
					<p>내용을 확인하셨으면 확인 버튼을 눌러주세요.</p>
					<Button color='green'>확인</Button>
				</div>
			);
		}
		- 컴포넌트의 element는 아래 모습을 갖는다.
		{
			type: 'div',
			props: {
				children: [
					{
						type: 'p',	<<<< 첫 번째 칠드런은 type이 html 태그 중 하나인 p 태그이기 때문에 곧바로 렌더링이 될 수 있는 상태
						props: {
							children: '내용을 확인하셨으면 확인 버튼을 눌러주세요.'
						}
					},
					{
						type: Button,	<<<< 하지만 두 번째 칠드런의 type은 React Component의 이름. 이 경우 React는 버튼 컴포넌트의 element를 생성해서 합치게 된다.
						props: {
							color: 'green',
							children: '확인
						}
					}
				]
			}
		}
		- Button 컴포넌트의 element 생성 후 최종 elements 모습
		{
			type: 'div',
			props: {
				children: [
					{
						type: 'p',
						props: {
							children: '내용을 확인하셨으면 확인 버튼을 눌러주세요.'
						}
					},
					{
						type: 'button',
						props: {
							className: 'bg-green',
							children: {
								type: 'b',
								props: {
									children: '확인'
								}
							}
						}
					}
				]
			}
		}

	> 이처럼 컴포넌트 렌더링을 위해서 모든 컴포넌트가 createElement 함수를 통해 element로 변환된다.	

8. Element의 특징
	> 불변성(immutable): 한 번 생성된 Element는 변하지 않는다. 즉, Element 생성 후에는 children이나 attribute를 바꿀 수 없다!
						 컴포넌트는 일종의 붕어빵 틀, elements는 그 붕어빵틀로 찍어낸 붕어빵들이다. 
						 이미 붕어빵이 완성된 후에 내용물을 바꿀 수 없듯이, element도 변경이 불가능하다.
						 브라우저 화면이 변경되는 경우, 기존의 element를 변경하는 것이 아니라 새로운 element를 만들어서 기존 element와 바꿔치기 한다. 
						 React에서는 Virtual DOM에서 변경된 부분의 엘리먼트를 새로 만들고 그 부분만 Browser DOM의 엘리먼트와 바꿔치기 한다. 
	
9. Element 렌더링
	★<div id="root"></div>★
	단순하지만 모든 리액트 앱에 필수적으로 들어가는 아주 중요한 코드
	이 div 태그 안에 리액트 엘리먼트들이 렌더링되며, 이것을 루트 돔 노드(Root DOM Node)라고 부른다.
	
	루트 div에 실제로 리액트 엘리먼트를 렌더링 하기 위해서는 다음과 같은 코드를 사용한다.
		const element = <h1>안녕, 리액트!</h1>;
		ReactDOM.render(element, document.getElementById('root'));
		> 이 코드는 엘리먼트를 하나 생성하고, 생성된 엘리먼트를 루트div에 렌더링하는 코드
		> 렌더링을 위해 리액트 돔의 렌더라는 함수를 사용한다.
		> 이 함수는 첫 번째 파라미터인 React Element를 두 번째 파라미터인 HTML Element, 즉 DOM Element에 렌더링하는 역할을 한다.
		> 여기서 다시 한 번 React Elements와 DOM Elements는 다른 개념이라는 것에 유의!!
		> React Element > React의 Virual DOM에 존재 / DOM Element > 실제 브라우저의 DOM에 존재
		> 결국 React 엘리먼트가 렌더링되는 과정은, Virual DOM에서 실제 DOM으로 이동하는 과정

		
