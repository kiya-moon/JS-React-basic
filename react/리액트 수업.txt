리액트 수업

1. 개발환경 설정하기
Node.js(JavaScript runtime) , npm(node package manager) 설치하기
* npm은 프로젝트에서 필요로 하는 다양한 외부 라이브러리의 버전을 관리하고 편하게 설치 및 삭제할 수 있도록 도와주는 역할
* Node.js를 설치하면 npm은 자동으로 설치된다.

VSCode 사용



2. 리액스 소개
React: A JavaScript library for building user interfaces
사용자 인터페이스를 만들기 위한 JavaScript 라이브러리

라이브러리는 자주 사용되는 기능들을 정리해서 모아 놓은 것
+
사용자 인터페이스(User Interface, UI): 사용자와 컴퓨터 프로그램이 서로 상호작용을 하기 위해 중간에서 입력과 출력을 제어해주는 것
=> UI 라이브러리

리액트는 대표적은 JavaScript UI 라이브러리



3. 리액트 장점
- 빠른 업데이트와 렌더링 속도
	> Virtual DOM을 사용해 빠른 업데이트 속도를 제공한다. 
	> DOM은 웹페이지를 정의하는 오브젝트
	> 화면이 업데이트 된다는 것은 DOM이 수정된다는 말
	> Virtual DOM은 페이지에서 수정된 부분만을 찾아 빠르게 업데이트 해준다.
- Component-Based
	> 모든 페이지가 Component로 구성되어 있음
	> 레고 블록을 조립하듯 컴포넌트들을 모아 개발
	> 재사용성(Reusability) ↑
	   - 개발 기간이 단축됨
	   - 유지보수가 용이함(문제가 생긴 모듈만 재배포하면 됨)
- Meta의 오픈소스이므로 꾸준한 버전 업데이트가 이루어지고 발전해나가고 있다.
- 활발한 지식공유 & 커뮤니티
- React Native를 이용해 모바일 개발도 할 수 있다.
	


4. 리액트 단점
- 방대한 학습량
- 높은 상태관리 복잡도



5. 리액트로 웹사이트를 만들 때, create-react-app(cra)을 사용
- Node.js v14.0.0 이상
- npm v6.14.0 이상
- VSCode
- 사용법: npx create-react-app <your-project-name>
- 실제 사용 예제: npx create-react-app my-app
- 경로 변경(change directory): cd my-app
- 애플리케이션 실행: npm start > localhost:3000으로 웹페이지가 실행됨
- create-react-app 공식 링크 : https://reactjs.org/docs/create-a-new-react-app.html



6. jsx
A syntax extension to JavaScript: JavaScript의 확장 문법
JavaScript + XML/html
ex. const element = <h1>Hello, world!</h1>;
- jsx의 역할: 내부적으로 XML/html 코드를 작성하여도 최종적으로는 JavaScript로 변환해주는 역할
	React.createElement(
		type,
		[props],
		[...children]
	)
	> 리액트의 createElement() 함수가 그 역할을 한다

- 예제 1
	> jsx를 사용한 코드
	class Hello Extends Reacat.Component {
		render() {
			return <div>Hello {this.props.toWhat}</div>;
		}
	}
	ReactDOM.render(
		<Hello toWhat = "World"	/>
		document.getElementById('root');
	)
	> JavaScript와 html을 같이 사용한 jsx 코드로 짜여진 Hello라는 리액트 컴포넌트를 
	> ReactDOM의 render() 함수를 이용해 브라우저 화면에 렌더링 해줌 

	> jsx를 사용하지 않은 코드
	class Hello Extends Reacat.Component {
		render() {
			return React.createElement('div', null, `Hello ${this.props.toWhat}`);
		}
	}
	ReactDOM.render(
		React.createElement(Hello, { toWhat: 'World' }, null),
		document.getElementById('root');
	)

- 예제 2
	> jsx를 사용한 코드
	const element = (
		<h1 className="greeting">
			Hello, world!
		</h1>
	)

	> jsx를 사용하지 않은 코드
	const element = React.createElement(
		'h1',
		{ classname: 'greeting },
		'Hello, world!'
	)

	> 결과: React.createElement()의 결과로 아래와 같은 객체가 생성된다.
	> 리액트에서는 이 객체를 React element라고 부른다.
	const element = {
		type: 'h1',
		props: {
			classname: 'greeting',
			children: 'Hello, world!'
		}
	}

- 리액트에서 꼭 jsx를 사용해야 하는 것은 아니나, jsx를 사용하면 생산성과 가독성이 올라가기 때문에 권장됨
- jsx 장점: 1. 간결한 코드 / 2. 가독성 > 버그를 발견하기 쉬움 / 3. Infection Attacks 방어

- jsx 사용 방법: JavaScript + XML/html 이 섞인 형태이기 때문에 기본적으로 JS의 모든 문법이 지원됨
	> ...XML/html
	  {JavaScript 코드}
	  ...XML/html

	> 변수 사용
		const name = '리액트';
		const element = <h1>안녕, {name}</h1>	<<<<
		ReactDOM.render(
			element,
			document.getElementById('root')
		)

	>함수 사용
		function formatName(user) {
			return user.firstName + ' ' + user.lastName;
		}
		const user = {
			fristName: 'Inje',
			lastName: 'Lee'
		};
		const element = (
			<h1>
				Hello, {formatName(user)}	<<<<
			</h1>
		);
		ReactDOM.render(
			element,
			document.getElementById('root')
		);

	> html 태그 사이가 아닌 태그 속성(attribute)에 값을 넣고 싶을 때
		// 큰따옴표 사이에 문자열을 넣거나
		const element = <div tabIndex="0"></div>;
		// 중괄호 사이에 JavaScript 코드를 넣으면 됨!
		const element = <img src={user.avatarUrl}></img>;
	
	> jsx에서는 중괄호{} 사이에 무조건 JavaScript가 들어간다고 외워두면 좋다!

	> jsx를 이용하여 자식(children)을 정의하는 방법: html에서 작성하듯이 상위 태그가 하위 태그를 둘러싸면 자연스럽게 자식이 정의된다.
	  여기서 div 태그의 자식은 h1, h2 태그
		const element = (
			<div>
				<h1>안녕하세요</h1>	<<<<
				<h2>열심히 리액트를 공부해 봅시다!</h2>	<<<<
			</div>
		);



7. element: 어떤 물체를 구성하는 성분
   React Element: 리액트를 구성하는 성분 > Elements are the smallest building blocks of React apps
   element는 원래 DOM(웹페이지의 모든 구성 정보를 담고 있는 객체)에서 사용하던 용어
   개발자도구의 'Elements' 탭에서 볼 수 있는 element들은 DOM Elements이며, 우리가 브라우저 화면에서 실제로 볼 수 있는 html 요소를 나타낸다.

   JavaScript 개발 초창기에, 화면에 나타나는 내용을 기술하는 자바스크립트 객체가 필요했음
   그래서 처음에는 기술하다는 의미를 가진 Describe에서 파생된 Descriptor로 불림
   그러나 Descriptor가 최종적으로 나타나는 형태는 DOM Elements였기 때문에, DOM과의 통일성을 위해 element로 부르게 됨

   Virtual DOM의 element가 React Elements. 이것을 렌더링 하면 Browser DOM의 DOM Elements가 된다.
   결국 React Elements는 DOM Elements의 가상 표현이라고 볼 수 있다.
   또한 DOM Elements는 React Elements에 비해 많은 정보를 담고 있기 때문에 크고 무겁다.

   React Elements는 화면에서 보이는 것들을 기술하고, 이것을 바탕으로 우리에게 실제로 보이는 DOM Elements가 만들어진다.

   React Elements는 JavaScript 객체 형태로 존재

   > element의 실제 모습을 알아보자!
   > 버튼을 나타내기 위한 element
   > 1. element의 type에 html 태그 이름이 문자열로 들어가는 경우
    	{
			type: 'button',
			props: {
				className: 'bg-green',
				children: {
					type: 'b',
					props: {
						children: 'Hello, element!'
					}
				}
			}
		}
		- 이 코드처럼 type에 html 태그 이름이 문자열로 들어가는 경우, element는 해당 태그 이름을 가진 DOM 노드를 나타내고, props는 속성에 해당한다. 
		- 그리고 이 element가 실제로 렌더링이 된다면, 아래와 같은 DOM Elements가 된다.
		 <button class='bg-green'>
			<b>
				Hello, element!
			</b>
		</button>

	> 2. element의 type에 html 태그 이름이 문자열로 들어가지 않는 경우
		{
			type: Button,
			props: {
				color: 'green',
				children: 'Hello, element!'
			}
		}
		- 이 JavaScript 코드는 React의 Component Element를 나타낸 것으로, 일반적인 JavaScript 객체
		- 다만 방금 전에 나왔던 element와 한 가지 다른 점은 type에 문자열로 된 html 태그가 아닌 React Component의 이름이 들어갔다는 점
		- 이처럼 React Element는 JavaScirpt 객체 형태로 존재한다.
		- 그리고 이 객체를 만드는 역할을 하는 것이 앞에서 나왔던 createElement() 함수이다.
		- 앞에서 createElement() 함수를 호출할 때 3가지의 파라미터를 넣었는데,
		React.createElement{
			type,
			[props],
			[...children]
		}
		- 첫 번째 파라미터: type
			~ html 태그 이름이 문자열로 들어가거나 React Component가 들어간다.
			~ React Component는 최종적으로는 HTML 태그를 사용하게 되어있는데,
			~ 하나의 컴포넌트는 여러 개의 자식 컴포넌트를 포함할 수 있고 자식 컴포넌트를 분해해보면 결국 HTML 태그가 나온다.
		- 두 번째 파라미터: props
			~ 간단히 말해 element의 속성(attributes)이라고 할 수 있음
			~ attributes보다 좀 더 상위의 개념이지만 element의 속성이라고 이해하고 나중에 더 자세하게 배울 예정
		- 세번째 파라미터: childeren
			~ 해당 엘리먼트의 자식 엘리먼트들이 이 부분에 들어가게 된다. 

	> 3. createElement() 함수가 동작하는 과정
		- 이 예제에는 Button 컴포넌트와 ConfirmDialog 컴포넌트가 있으며,
		- confirmDialog 컴포넌트가 button 컴포넌트를 포함하고 있다.
		function Button(props) {
			return (
				<button classname={`bg-${props.color}`}>
					<b>
						{props.children}
					</b>
				</button>
			);
		}

		function ConfirmDialog(props) {
			return (
				<div>
					<p>내용을 확인하셨으면 확인 버튼을 눌러주세요.</p>
					<Button color='green'>확인</Button>
				</div>
			);
		}
		- 컴포넌트의 element는 아래 모습을 갖는다.
		{
			type: 'div',
			props: {
				children: [
					{
						type: 'p',	<<<< 첫 번째 칠드런은 type이 html 태그 중 하나인 p 태그이기 때문에 곧바로 렌더링이 될 수 있는 상태
						props: {
							children: '내용을 확인하셨으면 확인 버튼을 눌러주세요.'
						}
					},
					{
						type: Button,	<<<< 하지만 두 번째 칠드런의 type은 React Component의 이름. 이 경우 React는 버튼 컴포넌트의 element를 생성해서 합치게 된다.
						props: {
							color: 'green',
							children: '확인
						}
					}
				]
			}
		}
		- Button 컴포넌트의 element 생성 후 최종 elements 모습
		{
			type: 'div',
			props: {
				children: [
					{
						type: 'p',
						props: {
							children: '내용을 확인하셨으면 확인 버튼을 눌러주세요.'
						}
					},
					{
						type: 'button',
						props: {
							className: 'bg-green',
							children: {
								type: 'b',
								props: {
									children: '확인'
								}
							}
						}
					}
				]
			}
		}

	> 이처럼 컴포넌트 렌더링을 위해서 모든 컴포넌트가 createElement() 함수를 통해 element로 변환된다.	

8. Element의 특징
	> 불변성(immutable): 한 번 생성된 Element는 변하지 않는다. 즉, Element 생성 후에는 children이나 attribute를 바꿀 수 없다!
						 컴포넌트는 일종의 붕어빵 틀, elements는 그 붕어빵틀로 찍어낸 붕어빵들이다. 
						 이미 붕어빵이 완성된 후에 내용물을 바꿀 수 없듯이, element도 변경이 불가능하다.
						 브라우저 화면이 변경되는 경우, 기존의 element를 변경하는 것이 아니라 새로운 element를 만들어서 기존 element와 바꿔치기 한다. 
						 React에서는 Virtual DOM에서 변경된 부분의 엘리먼트를 새로 만들고 그 부분만 Browser DOM의 엘리먼트와 바꿔치기 한다. 
	
9. Element 렌더링
	★<div id="root"></div>★
	단순하지만 모든 리액트 앱에 필수적으로 들어가는 아주 중요한 코드
	이 div 태그 안에 리액트 엘리먼트들이 렌더링되며, 이것을 루트 돔 노드(Root DOM Node)라고 부른다.
	
	루트 div에 실제로 리액트 엘리먼트를 렌더링 하기 위해서는 다음과 같은 코드를 사용한다.
		const element = <h1>안녕, 리액트!</h1>;
		ReactDOM.render(element, document.getElementById('root'));
		> 이 코드는 엘리먼트를 하나 생성하고, 생성된 엘리먼트를 루트div에 렌더링하는 코드
		> 렌더링을 위해 리액트 돔의 render() 함수를 사용한다.
		> 이 함수는 첫 번째 파라미터인 React Element를 두 번째 파라미터인 HTML Element, 즉 DOM Element에 렌더링하는 역할을 한다.
		> 여기서 다시 한 번 React Elements와 DOM Elements는 다른 개념이라는 것에 유의!!
		> React Element > React의 Virual DOM에 존재 / DOM Element > 실제 브라우저의 DOM에 존재
		> 결국 React 엘리먼트가 렌더링되는 과정은, Virual DOM에서 실제 DOM으로 이동하는 과정

		
10. Component
	> 하나의 페이지를 다양한 컴포넌트들이 모여서 구성함
	> 명령을 입력(Props; 속성)하면 React Component가 출력(React element; 리액트 앱을 구성하는 가장 작은 블록. 자바스크립트 객체 형태로 존재하며, 화면에 보이는 것을 기술)하는 구조로, JavaScript의 함수와 비슷한 기능을 함
	> 즉, 리액트 컴포넌트는 만들고자 하는 대로 props를 넣으면 해당 속성에 맞춰 화면에 나타날 엘리먼트를 만들어주는 것
	> Component라는 붕어빵 틀에서 element라는 붕어빵을 찍어내는 개념. 객체지향까지는 아니지만 클래스와 인스턴스의 개념과 비슷하다. 

11. Props
	> property + s ; 속성들
	> 컴포넌트가 붕어빵틀이라면 프롭스는 붕어빵의 속 재료
	> 컴포넌트에 전달할 다양한 정보를 담고 있는 자바스크립트 객체

	> 특징★. 읽기 전용 => 값을 변경할 수 없다!
		만약 변경하고 싶다면 새로운 값(props)을 컴포넌트에 전달하여 새로 엘리먼트를 생성해야 한다.
		All React components must act like pure functions with respect to their props.
		모든 리액트 컴포넌트는 pure 함수와 같은 기능을 해야 한다 = props를 직접 바꿀 수 없고, 같은 props에 대해서는 항상 같은 결과를 보여줘야 한다.
		* 자바스크립트의 pure function : 함수에 입력된 파라미터 값을 바꾸지 않는 함수
			function sum(a, b) {
				return a + b;
			}
		* 자바스크립트의 impure function : 함수에 입력된 파라미터 값을 바꾸는 함수
			function withdraw(account, amount) {
				account.total -= amount;
			}

	> 사용법
	- jsx를 사용하는 경우
		function App(props) {
			return (
				<Profile
					name="리액트"
					introduction="안녕하세요, 리액트 입니다."
					viewCount={1500}
			)
		} 
		=> 이 코드에서는 App 컴포넌트가 나오고, 그 안에서 Profile 컴포넌트를 사용하고 있다.
		   여기서 Profile 컴포넌트에 name, introduction, viewCount라는 세 가지 props를 넣어줌
		   문자열 이외에 정수, 변수, 다른 props가 들어갈 때는 중괄호를 사용한다. (문자열도 중괄호로 감싸도 상관은 없음)
		   * jsx를 배울 때, 중괄호 안에는 모두 자바스크립트 객체가 들어간다고 배움 

		   이렇게 하면 이 속성의 값은 모두 Porfile 컴포넌트의 props로 전달되며,
		   props는 아래와 같은 자바스크립트 객체가 된다.
		
		   {
				name: "리액트",
				introduction: "안녕하세요, 리액트 입니다.",
				viewCount: 1500
		   }

		function App(props)	{
			return (
				<Layout
					width={2500}
					height={1440}
					header={
						<Header title="리액트의 블로그입니다.">
					}
					footer={
						<Footer />
					}
			)
		}
		=> 중괄호를 사용하여 props의 값으로 컴포넌트도 넣을 수 있다.
		   이렇게 하면 레이아웃 컴포넌트의 props로는 정수 값을 가진 width, height와 리액트 엘리먼트로 header, footer가 들어오게 된다.

	- jsx를 사용하지 않는 경우, createElement() 함수 사용
		React.createElement(
			type,
			[props],
			[...children]
		)

		React.createElement(
			Profile,
			{
				name: "리액트",
				introduction: "안녕하세요, 리액트 입니다.",
				viewCount: 1500
			},
			null
		)
		=> type에는 컴포넌트의 이름인 Profile, props에는 자바스크립트 객체가 들어가고, 하위 컴포넌트는 없기 때문에 children에는 null이 들어감
		   실제로 사용 시에는 jsx 사용 권장

12. 컴포넌트 만들기
	> 컴포넌트는 크게 Function Component와 Class Component로 나뉘는데, 리액트 초기 버전에서는 클래스 컴포넌트를 주로 사용했으나 불편한 점이 많아 함수 컴포넌트를 개선하여 주로 사용하게 됨. 이 과정에서 Hook이 개발됨 

	> Function Component
	- 예제
		funtion Welcome(props) {
			return <h1>안녕, {props.name}</h1>
		}
		=> 간단한 코드를 장점으로 가진다.

	> Class Component
	JavaScript의 ES6의 class라는 것을 사용해 만들어진 형태의 컴포넌트
	함수 컴포넌트에 비해 몇 가지 추가적인 기능을 갖고 있음

	- 예제
		class Welcome extends React.Component {
			render() {
				return <h1>안녕, {props.name}</h1>;
			}
		}
		=> 함수 컴포넌트와의 가장 큰 차이점은, React의 모든 클래스 컴포넌트는 React.Component를 상속받아서 만든다.
		 
	> 컴포넌트 이름 : Component의 이름은 항상 대문자로 시작해야 한다★
	소문자로 시작하는 컴포넌트는 DOM 태그로 인식한다.
	예를 들어, div나 span과 같이 사용하는 것은 내장 컴포넌트라는 것을 뜻하며, div나 span 같은 문자열 형태로 react.createElement에 전달된다.
	하지만 Foo처럼 대문자로 시작하는 경우에는 react.createElement foo 형태로 컴파일되며, 자바스크립트 내에서 사용자가 정의했거나 임포트한 컴포넌트를 가리킨다.

	- 예제 1. DOM 태그를 사용한 element
		const element = <div />;
		=> HTML div 태그로 인식

	- 예제 2. 사용자가 정의한 Component를 사용한 element
		const element = <Welcom name="리액트" />;
		=> Welcom이라는 리액트 컴포넌트로 인식
		=> 소문자였다면 DOM 태그로 인식하여 에러가 발생하거나 원하는 결과가 나오지 않게 된다.

	> 컴포넌트 렌더링
	컴포넌트가 화면에서 보이는 것은 아니지만, 컴포넌트롤 통해 만들어진 엘리먼트가 실제 화면에 보이게 된다.

	- 렌더링
		// Welcome 함수 컴포넌트 선언
		function Welcome(props) {	
			return <h1>안녕, {props.name}</h1>
		}

		const element = <Welcome name="리액트" />

		// Welcome name = "리액트"라는 값을 가진 element를 파라미터로 해서 ReactDOM.render() 함수를 호출
		ReactDOM.render(
			element,
			document.getElementById('root')
		);

		=> 이렇게 하면 리액트는 Welcome 컴포넌트에 name="리액트"라는 props를 넣어서 호출하고, 그 결과로 리액트 앨리먼트가 생성된다.

13. 컴포넌트 합성
	> 리액트에서는 컴포넌트 안에서 다른 컴포넌트를 사용할 수 있기 때문에 복잡한 화면을 여러 개의 컴포넌트로 나눠서 구현할 수 있다.

	> 예제
		function Welcome(props) {
			return <h1>Hello, {props.name}</h1>;
		}

		function App(props) {
			return (
				<div>
					// props의 값을 다르게 해서 welcome 컴포넌트를 여러 번 사용
					<Welcome name="Mike" />
					<Welcome name="Steve" />
					<Welcome name="Jane" />
				</div>
			)
		}
		// => App이라는 컴포넌트는 welcome 컴포넌트를 3개 포함한 컴포넌트가 된다.
		// 이렇게 여러 개의 컴포넌트를 합쳐서 또 다른 컴포넌트를 만드는 것을 컴포넌트 합성이라고 한다.

		ReactDOM.render(
			<App />,
			document.getElementById('root')
		);

14. 컴포넌트 추출
	> 합성과 반대로 컴포넌트를 쪼개서 여러 개의 컴포넌트로 나누는 과정
	> 큰 컴포넌트에서 일부를 추출해서 새로운 컴포넌트를 만드는 것
	> 컴포넌트 추출을 잘 활용하게 되면 컴포넌트의 재사용성이 올라가게 된다.(개발속도 up)
	왜냐하면, 컴포넌트가 작아질수록 해당 컴포넌트의 기능과 목적이 명확해지고 props도 단순해지기 때문에 다른 곳에서 사용할 수 있는 확률이 높아지기 때문

	> 예제. 댓글을 표시하기 위한 컴포넌트
	  내부에 작성자의 프로필 이미지와 이름, 댓글내용, 작성일을 포함하고 있다.
		function Comment(props) {
			return (
				<div className="comment">
					<div className="user-info">
						<img classname="avatar"
							src={props.author.avatarUrl}
							alt={props.autohr.name}
						/>
						<div className="user-info-name">
							{props.author.name}
						</div>
					</div>

					<div className="comment-text">
						{props.text}
					</div>

					<div className="comment-date">
						{formatDate(props.date)}
					</div>
				</div>
			);
		}

	- 이 컴포넌트의 props
		props = {
			author: {
				name: "리액트",
				avatarUrl: "https://...",
			},
			text: "댓글입니다",
			date: Date.now(),
		}

	- Avatar 추출하여 별도의 컴포넌트로 만들기
		function Avatar(props) {
			return (
				<img classname="avatar"
					// props에 기존에 사용하던 author 대신 조금 더 보편적인 의미를 갖고 있는 user 사용
					// 보편적인 단어를 사용하는 것은 재사용성 측면을 고려하는 것
					src={props.user.avatarUrl}
					alt={props.user.name}
				/>
			);
		}

	- Comment 컴포넌트에 추출된 Avatar 컴포넌트 교체
		function Comment(props) {
			return (
				<div className="comment">
					<div className="user-info">
						<Avatar user={props.author} />
						<div className="user-info-name">
							{props.author.name}
						</div>
					</div>

					<div className="comment-text">
						{props.text}
					</div>

					<div className="comment-date">
						{formatDate(props.date)}
					</div>
				</div>
			);
		}

	- 사용자 정보를 담고 있는 부분 추출하여 UserInfo라는 컴포넌트로 만들기
		function UserInfo(props) {
			return (
				<div className="user-info">
					<Avatar user={props.user} />
					<div className="user-info-name">
						{props.user.name}
					</div>
				</div>
			);
		}

	- Comment 컴포넌트에 반영
		function Comment(props) {
			return (
				<div className="comment">
					<UserInfo user={props.author}>

					<div className="comment-text">
						{props.text}
					</div>

					<div className="comment-date">
						{formatDate(props.date)}
					</div>
				</div>
			);
		}

	> 컴포넌트를 어느 정도 수준까지 추출하는 것이 좋은 지에 대해 정해진 기준은 없다.
	다만, 기능 단위로 구분하는 것이 좋고 나중에 곧바고 재사용이 가능한 형태로 추출하는 것이 좋다.
	위 예제에서 추출한 아바타 컴포넌트나 유저 인포 컴포넌트는 다른 웹사이트를 만들 때에도 충분히 재사용이 가능하다.
	재사용이 가능한 컴포넌트를 많이 갖고 있을수록 개발 속도가 빨라진다.

15. State and Lifecycle
	> 주로 Class 컴포넌트와 관련된 내용이나, State라는 개념은 함수 컴포넌트에서도 사용되기 때문에 개념을 확실하게 이해하고 넘어가는 것이 좋다(리액트의 핵심!!)
	Lifecycle의 경우, 최근에는 Class 컴포넌트를 거의 사용하지 않기 때문에 가볍게 이해하고 넘어가기~ 

	> State
		- 리액트 Component의 상태 = 리액트 Component의 데이터란 의미에 가깝다
		- 쉽게 말해, 리액트 Component의 변경 가능한 데이터를 State라고 부른다.
		- State는 사전에 정의된 것이 아닌, 리액트 컴포넌트를 개발하는 개발자가 정의하여 사용한다.
		- 렌더링이나 데이터 흐름에 사용되는 값만 State에 포함시켜야 한다★
		왜냐하면 State가 변경될 경우 컴포넌트가 재렌더링 되는데, 렌더링과 데이터 흐름에 관련 없는 값을 포함하면 불필요한 경우에도 컴포넌트가 다시 렌더링되어 성능을 저하시킬 수 있기 때문이다.
		- 렌더링이나 데이터 흐름에 관련 없는 값은 컴포넌트의 인스턴스 필드로 정의
		- JavaScript 객체

		- 예제. LikeButton이라는 React 클래스 컴포넌트
			class LikeButton extends React.Component {
				// 모든 클래스 컴포넌트에는 constructor라는 이름의 함수가 존재
				// 생성자 : 클래스가 생성될 때 실행되는 함수
				constructor(props) {
					super(props);

					// 현재 컴포넌트의 state를 정의하는 부분
					// 클래스 컴포넌트의 경우 state를 생성자에서 정의하고, 함수 컴포넌트는 state를 useState라는 hook을 사용해서 정의한다.
					// 이렇게 정의된 state는 일반적인 JavaScript 변수를 다루듯이 직접 수정할 수 없다.(엄밀히 말하자면 수정이 가능하긴 하나 수정하면 안됨)
					this.state = {
						liked: false
					};
				}
				...
			}

		- state 수정
			~ state를 직접 수정 (잘못된 사용법)
				this.state = {
					name: 'React'
				};

			~ setState() 함수를 통한 수정 (정상적인 사용법)
				this.setState({
					name: 'React'
				});

	> Lifecycle : 리액트 Component의 생명주기
	- Mounting(출생) ~ Updating(인생) ~ Unmounting(사망)
	- Component는 계속 존재하는 것이 아니라, 시간의 흐름에 따라 생성되고 업데이트 되다가 사라진다(더 이상 상위 컴포넌트가 현재 컴포넌트를 화면에 표시하지 않을 때)
	- 함수 컴포넌트도 이런 흐름을 갖는다

16. Hooks
	> 리액트 16.8 버전에서 새롭게 등장한 개념
	> Class Component는 생성자에서 state를 정의하고, setState() 함수를 통해 state를 업데이트하며, 컴포넌트의 생명주기와 관련된 Lifecycle Methods가 모두 명확하게 정의되어 있기 때문에 잘 가져다 사용만 하면 되었음
	> Function Component는 Class Component와 다르게 코드도 굉장히 간결하고 별도로 state를 정의해서 사용하거나 컴포넌트의 생명주기에 맞춰 어떤 코드가 실행되도록 할 수 없음
	> Function Component에 이런 단점을 지원하기 위해서 나온 것이 Hooks!
	> 훅을 사용하면 함수 컴포넌트에서도 클래스 컴포넌트의 기능을 구현할 수 있다.

	> Hooks은 갈고리를 의미하는데, 프로그래밍에서는 원래 존재하는 어떤 기능에 마치 갈고리를 거는 것처럼 끼어들어가 같이 수행되는 것을 의미한다.
	> 리액트의 state와 lifecycle 기능에 갈고리를 걸어 원하는 시점에 정해진 함수를 실행되도록 만든 것

	> 이름은 모두 'use'로 시작된다★
	> 개발자가 직접 커스텀 훅을 만들어서 사용할 수도 있지만 이름은 꼭 use로 시작되어야 한다.

17. useState()
	> state를 사용하기 위한 훅

	> 사용법
	
		const [변수명, set함수명] = useState(초기값);
	
	- useState를 호출할 때는 파라미터로 선언할 state의 초기값이 들어간다.
	- return 값으로는 배열이 나온다.
	- return된 배열에는 두 가지 항목이 들어 있는데, 첫 번째 항목은 state로 선언된 변수이고, 두 번째 항목은 해당 state의 set 함수이다.

	> 예제
	- state를 사용하지 않은 카운터 컴포넌트
		import React from "react";

		function Counter(props) {
			var count = 0;

			return (
				<div>
					<p>총 {count}번 클릭했습니다.</p>
					<button onClick={() => count++}>
						클릭
					</button>
				</div>
			);
		}
		=> count를 함수의 변수로 선언해서 사용하게 되면, 버튼 클릭 시 카운트는 올라가지만 재렌더링되지는 않아 화면에 새로운 카운트 값이 나타나지 않는다.

	- useState 사용한 카운터 컴포넌트
		import React, { useState } from "react";

		function Counter(props) {
			const [count, setCount] = useState(0);

			return (
				<div>
					<p>총 {count}번 클릭했습니다.</p>
					<button onClick={() => setCount(count + 1)}>
						클릭
					</button>
				</div>
			);
		}

18. useEffect()
	> side effect를 수행하기 위한 훅
	> side effect는 부작용이라는 의미로, 프로그래밍에서는 개발자가 의도치 않은 코드가 실행되면서 버그가 나타나면 사이드 이펙트가 발생했다고 말한다. 하지만 리액트에서의 side effect는 부정적인 의미가 아닌 효과 혹은 영향을 뜻하는 effect의 의미에 가깝다. 예를 들면 서버에서 데이터를 받아오거나 수동으로 DOM을 변경하는 등의 작업을 가리키는데, 이 작업들은 다른 컴포넌트에 영향을 미칠 수 있으며 렌더링 중에는 작업이 완료될 수 없다(렌더링이 끝나야 실행될 수 있음). 그래서 이러한 작업들이 사이드로 실행된다는 의미에서 사이드 이펙트라 불린다.
	> useEffect는 클래스 컴포넌트에서 제공하는 생명주기 함수인 componentDidMount, componentDidUpdate, componentWillUnmount와 동일한 기능을 하나로 통합해서 제공

	> 사용법 
		useEffect(이펙트 함수, 의존성 배열);
	- 첫 번째 파라미터로는 이펙트 함수가 들어가고, 두 번째 파라미터로는 의존성 배열이 들어간다.
	- 의존성 배열은 말 그대로 이 이펙트가 의존하고 있는 배열인데, 배열 안에 있는 변수가 하나라도 값이 변경되면 이펙트 함수가 실행된다.
	- 기본적으로 이펙트 함수는 처음 컴포넌트가 렌더링 된 이후와 업데이트로 인한 재렌더링 이후에 실행된다. 
	- 만약 이펙트 함수가 mount 시와 unmount 시에 단 한 번씩만 실행되게 하고 싶으면 의존성 배열에 빈 배열을 넣으면 된다. => useEffect(이펙트 함수, []);
	- 이렇게 하면 해당 이펙트가 props나 state에 있는 어떤 값에도 의존하지 않는 것이 되므로 여러 번 실행되지 않는다.
	- 의존성 배열은 생략도 가능한데, 생략하게 되면 컴포넌트가 업데이트 될 때마다 호출된다. => useEffect(이펙트 함수);

	> 예제
	- componentDidMount, componentDidUpdate 기능 구현
		import React, { useState, useEffect } from "react";

		function Counter(props) {
			const [count, setCount] = useState(0);

			// componentDidMount, componentDidUpdate와 비슷하게 작동한다.
			useEffect(() => {
				// 브라우저 API를 사용해서 document의 title을 업데이트 한다.
				document.title = `You clicked ${count} times`;
			});

			return (
				<div>
					<p>총 {count}번 클릭했습니다.</p>
					<button onClick={() => setCount(count + 1)}>
						클릭
					</button>
				</div>
			);
		}
		=> 의존성 배열 없이 useEffect를 사용하면 리액트는 DOM이 변경된 후 해당 이펙트 함수를 실행하라는 의미로 받아들임
		그래서 기본적으로 컴포넌트가 처음 렌더링 될 때(componentDidMount)를 포함해서 매번 렌더링 될 때마다(componentDidUpdate) 이펙트가 실행된다.
		또한 이펙트는 함수 컴포넌트 안에서 선언되기 때문에 해당 컴포넌트의 props와 state에 접근할 수도 있다. 이 코드에서는 count라는 state에 접근하여 해당 값이 포함된 문자열을 생성해서 사용하는 것을 볼 수 있다.

	- componentWillUnmount 기능 구현
		import React, { useState, useEffect } from "react";

		function UserStatus(props) {
			const [isOnline, setIsOnline] = useState(null);

			function handleStatusChange(status) {
				setIsonline(status.isOnline);
			}

			useEffect(() => {
				ServerAPI.subscribeUserStatus(props.user.id, handleStatusChange);
				return () => {
					ServerAPI.unsubscribeUserStatus(props.user.id, handleStatusChange);
				};
			});

			if (isOnline === null) {
				return '대기 중...';
			}

			return isOnline ? '온라인' : '오프라인';
		}
		=> 이 코드는 useEffect에서 먼저 서버 API를 사용하여 사용자의 상태를 구독하고 있음. 이후 함수를 하나 리턴하는데, 해당 함수 안에는 구독을 해지하는 api를 호출하도록 되어 있음. 즉, useEffect의 리턴 함수는 컴포넌트의 mount가 해제될 때 호출되는데, componentWillUnmount() 함수의 역할과 동일하다. 

	- 하나의 컴포넌트에 여러 개의 훅 사용 가능
		import React, { useState, useEffect } from "react";

		function UserStatusWithCounter(props) {
			const [count, setCount] = useState(0);
			useEffect(() => {
				document.title = `총 ${count}번 클릭했습니다.`;
			});

			const [isOnline, setIsOnline] = useState(null);
			useEffect(() => {
				ServerAPI.subscribeUserStatus(props.user.id, handleStatusChange);
				return () => {
					ServerAPI.unsubscribeUserStatus(props.user.id, handleStatusChange);
				};
			});

			function handleStatusChange(status) {
				setIsOnline(status.isOnline);
			}
		}
	
19. useMemo() : Memoized value를 리턴하는 훅
	> memoization : 컴퓨터분야에서 memoization은 최적화를 위해 사용하는 개념. 비용이 높은, 즉 연산량이 많은 함수의 호출 결과를 저장해 두었다가 같은 입력 값으로 함수를 호출하면 새로 함수를 호출하지 않고 이전에 저장해놨던 호출 결과를 바로 반환하는 것. 이렇게 하면 결과적으로 함수 호출 결과를 받기까지 걸리는 시간도 짧아질 뿐더러 불필요한 중복 연산도 하지 않기 때문에 컴퓨터의 자원을 적게 쓸 수 있다.
	> memoized value : memoization된 결과 값

	> 사용법

		const memoizedValue = useMemo(
			() => {
				// 연산량이 높은 작업을 수행하여 결과를 반환
				return computeExpensiveValue(의존성 변수1, 의존성 변수2);
			},
			[의존성 변수1], [의존성 변수2]
		);

	- useMemo 훅을 사용하면 컴포넌트가 다시 렌더링 될 때마다 연산량 높은 작업을 반복하는 것을 피할 수 있다 => 빠른 렌더링 속도

	> useMemo로 전달된 함수는 렌더링이 일어나는 동안 실행된다. 때문에 side effect 같이 렌더링이 일어나는 동안 실행되면 안되는 작업을 useMemo의 함수에 넣으면 안된다.
	ex. 서버에서 데이터를 받아오거나 수동으로 DOM을 변경하는 작업 등

	> 의존성 배열을 넣지 않을 경우 매 렌더링마다 create() 함수가 실행된다. 따라서 useMemo 훅에 의존성 배열을 넣지 않고 사용하는 것은 의미가 없다.
	(연산량이 많은 값을 저장해놓기 위해 사용하는 훅인데, 매 렌더링 시마다 함수가 실행되면 의미가 없다는 뜻인가 보다...)

		const memoizedValue = useMemo(
			() => computeExpensiveValue(a, b)
		);

	> 의존성 배열이 빈 배열일 경우, 컴포넌트 마운트 시에만 호출 된다 => 마운트 시점에서 값을 한 번만 계산하면 되는 경우에 사용

		const memoizedValue = useMemo(
			() => {
				return computeExpensiveValue(a, b);
			},
			[]
		)

	> 하지만 대부분의 경우에는 의존성 배열에 변수들을 넣고, 그 변수들이 변경될 경우 새로 값을 계산해야 하는 경우에 useMemo를 사용한다.

20. useCallback()
	> useMemo()와 유사하지만 값이 아닌 함수를 반환한다.
	> 컴포넌트가 렌더링 될 때마다 함수를 새로 정의하는 것이 아니라 의존성 배열의 값이 바뀐 경우에만 함수를 새로 정의해서 리턴해주는 역할

	> 사용법

		const memoizedCallback = useCallback(
			() => {
				doSomething(의존성 변수1, 의존성 변수2);
			},
			[의존성 변수1, 의존성 변수2]
		);

	- useCallback 훅은 useMemo 훅과 마찬가지로 함수와 의존성 배열을 파라미터로 받는다.
	- useCallback 훅에서는 파라미터로 받는 이 함수를 callback이라고 부른다.
	
	> 의존성 배열에 있는 변수 중 하나라도 변경되면 메모이제이션된 콜백 함수를 반환한다. 의존성 배열에 따라 메모이즈드 값을 반환한다는 점에서는 useMemo 훅과 완전히 동일하다.
		useCallback(함수, 의존성 배열);
		useMemo(() => 함수, 의존성 배열);

	> 만약 useCallback 훅을 사용하지 않고 컴포넌트 내에 함수를 정의한다면, 매번 렌더링이 일어날 때마다 함수가 새로 정의된다. 따라서 useCallback 훅을 사용하여 특정 변수의 값이 변한 경우에만 함수를 다시 정의하도록 해서 불필요한 반복 작업을 없애준다.

	- 컴포넌트 내에 함수를 정의한 경우
		import { useState } from "react";

		function ParentComponent(props) {
			const [count, setCount] = useState(0);

			// 재렌더링 될 때마다 매번 함수가 새로 정의됨
			const handleClick = (event) => {
				//클릭 이벤트 처리
			};

			return (
				<div>
					<button 
						onClick={() => {
							setCount(count + 1);
						}}
					>
						{count}
					</button>

					<ChildComponent handleClick={handleClick} />
				</div>
			);
		}
		=> useCallback 훅을 사용하지 않고 컴포넌트 내에서 정의한 함수를 자식 컴포넌트의 props로 넘겨 사용하는 경우에 부모 컴포넌트가 재렌더링 될 때마다 자식 컴포넌트도 재렌더링된다.

	- useCallback 훅 사용한 경우
		import { useState, useCallback } from "react";

		function ParentComponent(props) {
			const [count, setCount] = useState(0);

			// 컴포넌트가 마운트 될 때만 함수가 정의됨
			const handleClick = useCallback((event) => {
				//클릭 이벤트 처리
			}, []);

			return (
				<div>
					<button 
						onClick={() => {
							setCount(count + 1);
						}}
					>
						{count}
					</button>

					<ChildComponent handleClick={handleClick} />
				</div>
			);
		}
		=> useCallback의 의존성 배열이 빈 배열로 주어졌기 때문에 컴포넌트가 마운트 될 때만 함수가 정의되고, 자식 컴포넌트도 불필요하게 재렌더링되지 않는다.

21. useRef()
	> Reference를 사용하기 위한 훅
	> 리액트에서 레퍼런스란 특정 컴포넌트에 접근할 수 있는 객체를 의미하며, useRef 훅은 이 레퍼런스 객체를 반환한다.
	> 이렇게 반환된 레퍼런스 객체는 컴포넌트의 라이프타임 전체에 걸쳐서 유지된다. 즉, 컴포넌트가 마운트 해제되기 전까지는 계속 유지된다.
	
	> 레퍼런스 객체에는 current라는 속성이 있는데 이것은 현재 레퍼런스하고 있는 엘리먼트를 의미한다 => refobject.current = 현재 참조하고 있는 Element

	> 사용법
		
		const refContainer = useRef(초기값);
	
	> 예제. useRef 훅을 사용하여 버튼 클릭 시 input에 포커스를 하도록 하는 코드
		function TextInputWithFocusButton(props) {
			// 초기값: null
			const inputElem = useRef(null);

			// 버튼 클릭 시 호출되는 함수
			// inputElem.current를 통해 실제 엘리먼트에 접근하여 포커스 함수를 호출
			const onButtonClick = () => {
				// `current`는 마운트된 input element를 가리킨다
				inputElem.current.focus();
			};

			return (
				<>
					// 반환된 레퍼런스 객체 inputElem을 input 태그에 넣어줌
					<input ref={inputElem} type="text" />
					<button onClick={onButtonClick}>
						Focus the input
					</button>
				</>
			);
		}
	
	> <div ref={myRef} />
	- 리액트에서는 화면과 같이 코드를 작성하면 노드가 변경될 때마다 myref의 current 속성에 현재 해당되는 DOM 노드를 저장한다.
	- ref 속성과 기능은 비슷하지만 useRef 훅은 클래스의 instance 필드를 사용하는 것과 유사하게 다양한 변수를 저장할 수 있다는 장점이 있다.
	- 이런 것이 가능한 이유는 useRef 훅이 일반적인 자바스크립트 객체를 리턴하기 때문
	
	> 내가 직접 current 속성이 포함된 자바스크립트 객체를 만들어 쓴다면? 
	- 물론 목적 달성은 가능할 수 있지만 useRef 훅을 사용하는 것과 직접 current 속성이 포함된 자바스크립트 객체를 만들어 사용하는 것의 차이점은 useRef 훅은 매번 렌더링이 될 때마다 항상 같은 레퍼런스 객체를 반환한다는 점이다.

	> useRef 훅은 내부의 데이터가 변경되었을 때 별도로 알리지 않는다. 그래서 current 속성을 변경한다고 해서 재렌더링이 일어나진 않는다. 따라서 Ref에 DOM 노드가 연결되거나 분리되었을 경우에 어떤 코드를 실행하고 싶다면 콜백 레프(Callback ref)를 사용해야 한다.
	- Callback ref : DOM 노드의 변화를 알기 위한 가장 기초적인 방법
	- 리액트는 ref가 다른 노드에 연결될 때마다 callback을 호출하게 됨

	- 예제. useRef() 가아닌 useCallback()을 사용하는 callback ref 방식
	 	~ useRef 훅을 사용하게 되면 레퍼런스 객체가 current 속성이 변경되었는지를 따로 알려주지 않기 때문에 useCallback 훅 사용
		~ Callback ref 방식을 사용하면 자식 컴포넌트가 변경되었을 때 알림을 받을 수 있고, 이를 통해 다른 정보들을 업데이트 할 수 있다.
		
		function MeasureExample(props) {
			const [height, setHeight] = useState(0);

			const measuredRef = useCallback(node => {
				if (node !== null) {
					setHeight(node.getBoundingClientRect().height);
				}
			}, []);

			return (
				<>
					<h1 ref={measuredRef}>안녕, 리액트</h1>
					<h2>위 헤더의 높이는 {Math.round(height)}px 입니다.</h2>
				</>
			);
		}
		=> 이 예제 코드에서는 h1 태그의 높이 값을 매번 업데이트하고 있음
		그리고 useCallback 훅의 의존성 배열로 비어있는 배열을 넣어 h1 태그가 mount, unmount 될 때만 callback() 함수가 호출되며 재렌더링 시에는 호출되지 않는다.

22. 훅의 규칙
	> 훅은 무조건 최상위 레벨에서만 호출해야 한다★
	- 여기서 말하는 최상위 레벨은 리액트 함수 컴포넌트의 최상위 레벨
	- 반복문이나 조건문 또는 중첨된 함수들 안에서 훅을 호출하면 안된다는 뜻
	- 이 규칙에 따라 훅은 컴포넌트가 렌더링 될 때마다 매번 같은 순서로 호출되어야 한다.
	- 이렇게 해야 리액트가 다수의 useState 훅과 useEffect 훅을 호출해서 컴포넌트의 state를 올바르게 관리할 수 있게 된다.

	- 예제. 잘못된 훅 사용법
		function MyComponent(props) {
			const [name, setName] = useState('React');

			if (name !== '') {
				useeffect(() => {
					...
				});
			}
			...
		}
		=> 이 코드에서는 if문에 들어간 조건문의 값이 참인 경우에만 useEffect 훅을 호출하도록 되어 있음.
		이런 경우 name의 값이 빈 문자열이 되면 조건문의 값이 false가 되어 useEffect 훅이 호출되지 않는다.
		결과적으로 렌더링 할 때마다 훅이 같은 순서대로 호출되는 것이 아니라 조건문의 결과에 따라 호출되는 훅이 달라지는 잘못된 코드이다.

	> 훅은 리액트 함수 컴포넌트에서만 호출해야 한다★
	- 일반적인 JavaScript 함수에서 훅 호출 X
	- 리액트 함수 컴포넌트에서 호출하거나 직접 만든 커스텀 훅에서만 호출할 수 있다.
	- 이 규칙에 따라 리액트 컴포넌트에 있는 state와 관련된 모든 로직은 소스 코드를 통해 명확하게 확인이 가능해야 한다.

	> eslint-plugin-react-hooks : 훅의 규칙을 따르도록 강제해주는 플러그인
	- eslint는 JavaScript 코드에서 발견되는 문제 패턴을 식별하기 위한 정적 코드 분석 도구
	- 이 플러그인을 사용하면 리액트 컴포넌트가 훅의 규칙을 따르는 지 아닌 지 분석할 수 있다.
	- 의존성 배열이 잘못되어 있는 경우 자동으로 경고 표시를 해주며 고칠 방법을 제안
	- https://www.npmjs.com/package/eslint-plugin-react-hooks

23. Custom Hook
	> 리액트에서 기본적으로 제공되는 훅 이외에 추가적으로 필요한 기능이 있다면 직접 훅을 만들어 사용할 수 있다.
	> 여러 컴포넌트에서 반복적으로 사용되는 로직을 훅으로 만들어 재사용하기 위해서 만든다.

	> Custom Hook을 만들어야 하는 상황
	- 사용자의 상태가 온라인인지 오프라인인지 보여주는 컴포넌트
		import React, { useState, useEffect } from "react";

		function UserStatus(props) {
			const [isOnline, setIsOnline] = useState(null);

			useEffect(() => {
				function handleStatusChange(status){
					setIsOnline(status.isOnline);
				}

				ServerAPI.subscribeUserStatus(props.user.id, handleStatusChange);
				return () => {
					ServerAPI.unsubscribeUserStatus(props.user.id, handleStatusChange);
				};
			});

			if (isOnline === null) {
				return '대기중...';
			}
			return isOnline ? '온라인' : '오프라인';
		}
		
	- 동일한 웹사이트에서 연락처 목록을 제공하는데, 이 때 온라인인 사용자의 이름은 초록색으로 표시하는 컴포넌트
		import React, { useState, useEffect } from "react";

		function UserListItem(props) {
			const [isOnline, setIsOnline] = useState(null);

			useEffect(() => {
				function handleStatusChange(status){
					setIsOnline(status.isOnline);
				}

				ServerAPI.subscribeUserStatus(props.user.id, handleStatusChange);
				return () => {
					ServerAPI.unsubscribeUserStatus(props.user.id, handleStatusChange);
				};
			});

			return (
				<li style={{color: isOnline ? 'green' : 'black'}}>
					{props.user.name}
				</li>
			);
		}

	- 위 두 컴포넌트를 살펴보면 UserStatus와 UseState, UseEffectHook을 사용하는 부분이 동일한 것을 볼 수 있다.
	- 기존의 리액트에서는 보통 이렇게 state와 관련된 로직이 중복되는 경우에 Render props 또는 HCO(Highter Order Component)를 사용
	- 여기서는 중복되는 코드를 추출하여 커스텀 훅으로 만들어본다.

	> Custom Hook 추출하기
	- 두 개의 JavaScript 함수에서 하나의 로직을 공유하도록 하고 싶을 때에는 새로 함수를 하나 만드는 방법을 사용
	- 리액트 Function Component와 Hook은 모두 함수이기 때문에 동일한 방법 사용
	- Custom Hook은 이름이 use로 시작하고 내부에서 다른 Hook을 호출하는 하나의 자바스크립트 함수

	- 중복되는 로직 추출하여 useUserStatus라는 커스텀 훅 만들기
		import { useState, useEffect } from "react";

		function useUserStatus(userId) {
			const [isOnline, setIsOnline] = useState(null);

			useEffect(() => {
				function handleStatusChange(status){
					setIsOnline(status.isOnline);
				}

				ServerAPI.subscribeUserStatus(userId, handleStatusChange);
				return () => {
					ServerAPI.unsubscribeUserStatus(userId, handleStatusChange);
				};
			});

			return isOnline;
		}
		=> userId를 파라미터로 받아 해당 사용자의 온라인/오프라인 상태를 리턴하도록 함

	- 커스텀 훅은 규칙이 따로 없다. 파라미터로 무엇을 받을 지 어떤 것을 리턴해야 할 지를 개발자가 직접 정할 수 있다. 다시 말하면 커스텀 훅은 단순한 함수와도 같다. 다만 이름 앞에 use를 붙여 단순한 함수와 구분지어 준다.
	- 또한 훅의 두 가지 규칙은 그대로 적용된다.
		~ 훅은 무조건 최상위 레벨에서만 호출해야 한다
		~ 훅은 리액트 함수 컴포넌트에서만 호출해야 한다

	> Custom Hook 사용하기
		function userStatus(props) {
			const isOnline = useUserStatus(props.user.id);

			if (isOnline === null) {
				return '대기중...';
			}
			return isOnline ? '온라인' : '오프라인';
		}

		function UserListitem(props) {
			const isOnline = useUserStatus(props.user.id);

			return (
				<li style={{color: isOnline ? 'green' : 'black'}}>
					{props.user.name}
				</li>
			);
		}

		=> 이 코드는 커스텀 훅을 적용하기 전과 동일하게 작동한다.
		두 개의 컴포넌트에서 같은 커스텀 훅을 사용하고 있지만 state를 공유하는 것은 아니다. 단순히 state와 연관된 로직을 재사용이 가능하게 만든 것

	- 여러 개의 컴포넌트에서 하나의 Custom Hook을 사용할 때 컴포넌트 내부에 있는 모든 state와 effects는 전부 분리되어 있다. 리액트 컴포넌트는 각각의 커스텀 훅 호출에 대해서 분리된 state를 얻기 때문

	> Hook들 사이에서 데이터를 공유하는 방법
	- 각각의 훅은 모두 독립적
	- 예제. select 태그를 통해 목록에서 사용자를 선택할 수 있게 해주고 있으며, 사용자를 선택할 경우 해당 사용자가 온라인인지 아닌지를 보여주는 컴포넌트
		const userList = [
			{ id: 1, name: 'React' },
			{ id: 2, name: 'JS' },
			{ id: 3, name: 'JAVA' },
		];

		function ChatuserSelector(props) {
			// useState 훅을 이용하여 userId라는 state를 만듦
			// 현재 선택된 사용자의 아이디를 저장하기 위한 용도
			const [userId, setUserId] = useState(1);

			// 만들어진 userId는 useUserStatus 훅의 파라미터로 들어감 
			// 이렇게 하면 setUserId를 통해 유저 아이디가 변경될 때마다, useUserStatus 훅은 이전에 선택된 사용자를 구독 취소하고 새로 선택된 사용자의 온라인 여부를 구독하게 됨
			const isUserOnline = useUserStatus(userId);

			// => 훅들 사이에서는 이러한 방법으로 데이터를 공유할 수 있다.
			// 참고로 알아두기

			return (
				<>
					<Circle color={isUserOnline ? 'green' : 'red'} />
					<select
						value={userId}
						onChange={event => setUserId(Number(event.target.value))}
					>
						{userList.map(user => (
							<option key={user.id} value={user.id}>
								{user.name}
							</option>
						))}
					</select>
				</>
			);
		}

24. Event Handler
	 > Event : 프로그래밍에서의 이벤트는 특정 사건을 의미. 버튼 클릭 등
	 > DOM에서의 Event
		<button onclick="activate()">
			Activate
		</button>
		=> 클릭 이벤트를 처리할 함수를 onclick을 통해서 전달
	> React에서의 Event
		<button onClick={activate}>
			Activate
		</button> 	
	> 차이점 1. onClick이 camel 표기법으로 되어있음
	> 차이점 2. DOM에서는 문자열로 전달하지만, React에서는 함수 그대로 전달

	> Event Handler : 어떤 사건이 발생하면 사건을 처리하는 역할(=Event Listener)

	> Class Component에서 사용 시(지금은 거의 사용하지 않으므로 참고만)
	- 예제1. bind 사용
		~ Toggle이라는 컴포넌트
		~ isToggleOn이라는 Boolean 변수를 state로 갖는다
		~ 버튼을 클릭하면 이벤트 핸들러 함수인 handleClick() 함수를 호출하도록 되어 있음

		class Toggle extends React.Component {
			constructor(props) {
				super(props);

				this.state = { isToggleOn: true };

				// 아래에서 정의된 handleClick() 함수를 bind를 사용해서 대입해준다
				// callback에서 `this`를 사용하기 위해서는 바인딩을 필수적으로 해줘야 한다.
				// 필수적인 이유는 자바스크립트에서는 기본적으로 클래스 함수들이 바운드되지 않기 때문
				// 그래서 바인드를 하지 않으면 this.handleClick은 글로벌스코프에서 호출되는데,
				// 글로벌스코프에서 this.handleClick은 undefined이므로 사용할 수가 없다. 
				// 리액트 뿐만 아니라 자바스크립트 함수의 작동원리의 일부분으로, 일반적으로 함수의 이름 뒤에 괄호 없이 사용하려면 무조건 해당 함수를 바인드 해줘야 한다.
				// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind 참조
				this.handleClick = this.handleClick.bind(this);
			}

			// handleClick() 함수 정의
			handleClick() {
				this.setState(prevState => ({
					isToggleOn: !prevState.isToggleOn
				}));
			}

			render() {
				return (
					<button onClick={this.handleClick}>
						{this.state.isToggleOn ? '켜짐' : '꺼짐'}
					</button>
				);
			}
		}

	- 예제2. Class fields syntax 사용
		class MyButton extends React.Component {
			// Class fields syntax 부분
			handleClick = () => {
				console.log('this is:', this);
			}

			render() {
				return (
					<button onClick={this.handleClick}>
						클릭
					</button>
				);
			}
		}

	- 예제3. 바인드, Class fields syntax도 사용하지 않는 방법
		~ 이벤트 핸들러 넣는 부분에 arrow function을 넣는다
		~ 이 방식은 MyButton 컴포넌트가 렌더링 될 때마다 다른 콜백 함수가 생성되는 문제가 있음
		~ 대부분의 경우는 상관없지만, 이 콜백 함수가 하위 컴포넌트에 props로 넘겨지게 되면 하위 컴포넌트에서 추가적인 렌더링이 발생하게 됩니다. 
		~ 그래서 성능 문제를 피하기 위해서 바인딩이나 클래스 필드 신택스 방법을 사용하는 것을 권장

		class MyButton extends React.Component {
			handleClick() {
				console.log('this is:', this);
			}

			render() {
				return (
					<button onClick={() => this.handleClick()}>
						클릭
					</button>
				);
			}
		}
	
	> Function Component에서 사용 시
	- 예제
		function Toggle(props) {
			const [isToggleOn, setIsToggleOn] = useState(true);

			// 방법1.함수 안에 함수로 정의
			function handleClick() {
				setIsToggleOn((isToggleOn) => !isToggleOn);
			}

			// 방법2. arrow function을 사용하여 정의
			const handleClick = () => {
				setIsToggleOn((isToggleOn) => !isToggleOn);
			}

			render() {
				return (
					<button onClick={handleClick}>
						{isToggleOn ? '켜짐' : '꺼짐'}
					</button>
				);
			}
		}

25. Event Handler에 Argument 전달
	> Argument: 주장, 논쟁, 말다툼. 여기서는 주장이라는 의미에 더 가까우며 함수에 주장할 데이터, 즉 함수에 전달할 데이터를 가리킴
	> 같은 의미로 Parameter(매개변수)도 많이 사용

	> 예제
	- Class Component에서 사용되는 방법(참고만)
		~ Arrow Function 사용 시
		~ 명시적으로 이벤트를 두 번째 매개변수로 전달
		<button onClick={(event) => this.deleteItem(id, event)}>삭제하기</button>

		~ bind 사용 시
		~ id 이후에 event가 자동으로 두 번째 매개변수로 전달됨
		<button onClick={this.deleteItem.bind(this, id)}>삭제하기</button>

	- Function Component에서 사용되는 방법
		function MyButton(props) {
			// 매개변수의 순서는 원하는 대로 변경해도 상관 없음
			const handleDelete = (id, event) => {
				console.log(id, event.target);
			};

			return (
				<button onClick={(event) => handleDelete(1, event)}>
					삭제하기
				</button>
			);
		}

26. Conditional Rendering
	> Condition: 조건, 상태. 프로그래밍에서는 조건을 의미
	> Conditional Rendering: 조건부 렌더링. 즉, 어떠한 조건에 따라서 렌더링이 달라지는 것을 의미. 여기에서 조건은 우리가 프로그래밍에서 사용하는 조건문. 조건문의 결과인 true, false에 따라서 렌더링을 다르게 하는 것을 조건부 렌더링이라고 정의한다
	> 예를 들어, true이면 버튼을 보여주고 false이면 버튼을 가리는 것도 하나의 조건부 렌더링이라고 할 수 있다

	> 예제
		fucntion UserGreeting(props) {
			return <h1>다시 오셨군요!</h1>
		}

		function GuestGreeting(props) {
			return <h1>회원가입을 해주세요.</h1>
		}

		function Greeting(props) {
			const isLoggedIn = props.isLoggedIn;

			if(isLoggedIn) {
				return <UserGreeting />;
			}
			return <GuestGreeting />;
		}
		=> isLoggedIn이 true라면 UserGreeting 컴포넌트가 보여지고, false라면 GuestGreeting 컴포넌트가 보여진다

	> JavaScript의 Truthy와 Falsy
	- 보통의 프로그래밍 언어에서는 참(True)과 거짓(False)을 구분하기 위해 Boolean 자료형이 존재
	- 자바스크립트에서는 ture는 아니지만 true로 여겨지는 값(Truthy)과 false는 아니지만 false로 여겨지는 값(Falsy)이 존재

	- Truthy
		~ true
		~ {} (empty objects)
		~ [] (empty array)
		~ 42 (number, not zero)
		~ "0", "false" (string, not empty)

	- Falsy
		~ false
		~ 0, -0 (zero, minus zero)
		~ 0n (BigInt zero)
		~ '', "", `` (empty string)
		~ null
		~ undefined
		~ NaN (not a number)

27. Element Variables
	> 조건부 렌더링을 사용하다 보면 렌더링 해야 될 컴포넌트를 변수처럼 다루고 싶을 때가 있는데, 이 때 사용할 수 있는 방법
	> 리액트의 Element를 변수처럼 다룬다

	> 예제
		function LoginButton(props) {
			return (
				<button onClick={props.onClick}>
					로그인
				</button>
			);
		}

		function LogoutButton(props) {
			return (
				<button onClick={props.onClick}>
					로그아웃
				</button>
			)
		}

		// LoginControl 컴포넌트는 사용자의 로그인 여부에 따라
		// LoginButton과 LogoutButton 두 개의 컴포넌트를 선택적으로 보여준다
		function LoginControl(props) {
			const [isLoggedIn, setIsLoggedIn] = useState(false);

			const handleLoginClick = () => {
				setIsLoggedIn(true);
			}

			const handleLogoutClick = () => {
				setIsLoggedIn(false);
			}

			// isLoggedIn의 값에 따라서 버튼이라는 변수에 컴포넌트를 대입
			let button;
			if (isLoggedIn) {
				button = <LogoutButton onClick={handleLogoutClick} />;
			} else {
				button = <LoginButton onClick={handleLoginClick} />;
			}
		}

		// 컴포넌트가 대입된 변수를 return에 넣어 실제로 컴포넌트(컴포넌트로부터 생성된 리액트 엘리먼트)가 렌더링되도록 한다
		// 이처럼 Element Variables은 엘리먼트를 변수처럼 저장해서 사용
		return (
			<div>
				<Greeting isLoggedIn={isLoggedIn} />
				{button}
			</div>
		)

		~ 위 예제처럼 별도로 변수를 선언해서 조건부 렌더링을 할 수도 있지만, 인라인 조건문을 사용하면 조금 더 코드를 간결하게 작성할 수 있다

28. Inline Conditions
	> 코드를 별도로 분리된 곳에 작성하지 않고, 해당 코드가 필요한 곳 안에 직접 집어넣는 방식. 즉, 조건문을 코드 안에 집어넣어 작성한다

	> Inline If
	- if문을 필요한 곳에 직접 집어넣어 사용하는 방법
	- 다만 실제로 if문을 넣는 것은 아니고 && 논리연산자를 사용

	- && : Logical And 연산자. 양쪽에 나오는 조건문이 모두 true인 경우에만 true 값을 반환한다
	- 단축평가(Short Circuit Evaluation) : 결과가 정해져 있는 논리 연산에서 굳이 불필요한 연산은 하지 않기 위해 사용하는 방법
	
		true && expression => expression
	
		false && expression => false  
	
		=> 첫 번째 조건문이 true이면 두 번째 조건문을 평가하고, 첫 번째 조건문이 false이면 어차피 결과값은 false가 되기 때문에 두 번째 조건문을 평가하지 않는다 

	- Inline If는 이 && 연산자를 jsx 코드 안에서 중괄호를 사용하여 직접 집어넣어 사용

	- 예제
		function Mailbox(props) {
			const unreadMessages = props.unreadMessages;

			return (
				<div>
					<h1>안녕하세요!</h1>
					{unreadMessages.length > 0 &&
						<h2>
							현재 {unreadMessages.length}개의 읽지 않은 메세지가 있습니다.
						</h2>	
					}
				</div>
			);
		}
		=> unreadMessages.length가 0 보다 큰 지 평가하는 조건문의 결과값에 따라서 뒤에 나오는 h2 태그로 둘러싸인 부분이 렌더링이 되거나 안 되거나 하게 됨. 만약 unreadMessages.length가 0 보다 크다면 뒤에 나오는 h2 태그 부분이 렌더링 될 것이고, unreadMessages.length가 0 보다 작으면 아무것도 렌더링되지 않는다 
	
	- && 연산자를 사용하는 이러한 패턴은 리액트에서 많이 사용되기 때문에 꼭 기억할 것!

	- 주의점. && 연산자를 사용할 때 조건문에 false expression을 사용하면 뒤의 내용은 평가되지 않지만, false expression의 결과 값이 그대로 리턴되기 때문에 주의해야 한다
		~ 예제
			function Counter(props) {
				const count = 0;

				return (
					<div>
						{count && <h1>현재 카운트: {count}</h1>}
					</div>
				);
			}
			=> 이 코드의 결과는 화면에 아무것도 안 나오는 것이 아니라, count의 값인 0이 출력된다. 이런 상황을 방지하기 위해 조건문의 결과값은 무조건 boolean 타입이 되도록 해주는 것이 좋다
			(0은 falsy expression이어서 false가 되고, false 값이 그대로 출력되어 0이 출력되는 것 같음)

	> Inline If-Else
	- If-Else문을 필요한 곳에 직접 넣어서 사용하는 방법
	- Inline If는 보여주거나 안 보여주는 두 가지 경우만 있었지만, Inline If-Else는 조건문의 값에 따라 다른 엘리먼트롤 보여줄 때 사용
	- 이를 위해서 삼항 연산자라 불리는 ? 연산자를 사용
		condition ? true : false
	
	- 예제
		~ 삼항연산자에 문자열을 넣은 경우
			function UserStatus(props) {
				return (
					<div>
						이 사용자는 현재 <b>{props.isLoggedIn ? '로그인' : '로그인하지 않은'}</b> 상태입니다.
					</div>
				);
			}

		~ 삼항연산자에 엘리먼트를 넣은 경우
			function LoginControl(props) {
				const [isLoggedIn, setIsLoggedIn] = useState(false);

				const handleLoginClick = () => {
					setIsLoggedin(true);
				};

				const handleLogoutClick = () => {
					setIsLoggedIn(false);
				};

				return (
					<div>
						<Greeting isLoggedIn={isLoggedIn} />
						{isLoggedIn
							? <LogoutButton onClick={handleLogoutClick} />
							: <LoginButton onClick={handleLoginClick} />	
						}
					</div>
				);
			}

29. Component 렌더링 막기
	> 컴포넌트를 렌더링하고 싶지 않을 때 : null 리턴

	> 예제
		// props.warning이 false일 경우 아무것도 렌더링하지 않고
		// true일 경우에만 경고를 출력하는 컴포넌트
		function WarningBanner(props) {
			if (!props.warning) {
				return null;
			}

			return (
				<div>경고!</div>
			);
		}

		// 사용 시
		function MainPage(props) {
			const [showWarning, setShowWarning] = useState(false);

			const handleToggleClick = () => {
				setShowWarning(prevShowWarning => !prevShowWarning);
			};

			return (
				<div>
					<WarningBanner warning={showWarning} />
					<button onClick={handleToggleClick}>
						{showWarning ? '감추기' : '보이기'}
					</button>
				</div>
			);
		}
	
	> 참고로 Class Component의 render() 함수에서 null을 리턴하는 것은 컴포넌트의 생명주기에 영향을 미치지 않음. 예를 들어 null을 리턴하더라도 componentDidUpdate() 함수는 여전히 호출됨

30. List와 Key
	> List
	- List: 목록. 프로그래밍에서는 같은 아이템을 순서대로 모아 놓은 것
	- Array(배열): 리스트를 위해 사용하는 자료구조. 변수나 객체들을 하나의 변수로 묶어 놓은 것. 
	- ex. const numbers = [1, 2, 3, 4, 5];
	- 리액트에서는 이 배열을 사용해서 리스트 형태로 엘리먼트들을 렌더링 할 수 있다

	> Key
	- Key: 열쇠. 열쇠는 다 모양이 다르기 때문에 고유하기 때문에, 프로그래밍에서의 Key는 각 객체나 아이템을 구분할 수 있는 고유한 값을 의미한다
	- 리액트에서의 Key는 리스트에 존재하는 아이템들을 구분하기 위한 고유한 문자열

	> 리액트에서는 배열과 Key를 이용하여 여러 개의 Component를 렌더링 할 수 있다. (엄밀히 말하면 반복되는 다수의 엘리먼트가 렌더링 되는 것)
	
	> map() : mapping 역할. 배열에 들어있는 각 변수에 어떠한 처리를 하여 리턴
	- ex. const doubled = numbers.map((number) => number * 2);
		~ 이 코드는 map() 함수를 사용하여 numbers 배열에 들어있는 각 숫자에 2를 곱한 값이 값이 들어간 doubled라는 배열을 생성하는 코드
		~ 이처럼 map() 함수는 배열의 첫번째 아이템부터 순서대로 각 아이템의 어떠한 연산을 수행한 뒤에 최종결과를 배열로 만들어서 리턴해 준다고 보면 된다

	- 리액트에서의 map() 함수 사용
		// 1부터 5까지의 숫자가 들어가 있는 numbers 배열
		const numbers = [1, 2, 3, 4, 5];

		// map() 함수를 사용해서 이 배열에 들어있는 각 숫자를 li 태그로 감싸 리턴
		const listItems = numbers.map((number) => 
			<li>{number}</li>
		);

		const root = ReactDOM.createRoot(document.getElementById('root'));

		root.render(
			// ul 태그는 li 태그를 감싸는 태그
			<ul>{listItems}</ul>,
			document.getElementById('root')
		);
		=> 최종적으로 렌더링 되는 모습
			root.render(
			<ul>
				<li>{1}</li>
				<li>{2}</li>
				<li>{3}</li>
				<li>{4}</li>
				<li>{5}</li>
			</ul>,
			document.getElementById('root')
			);

	- 기본적인 List Component
		~ 위에 작성한 코드를 기본적인 형태를 가진 별도의 List Component로 분리
		
		// 숫자 목록을 출력하는 NumberList 컴포넌트
		fucntion NumberList(props) {
			// props로 숫자가 들어있는 배열 numbers를 받음
			const { numbers } = props;

			// props로 받은 number에 li 태그를 붙여 listItems 배열로 리턴
			cosnt listItems = numbers.map((number) => 
				<li>{number}</li>
			);

			// 이를 목록으로 출력
			return (
				<ul>{listItems}</ul>
			);
		}

		const numbers = [1, 2, 3, 4, 5];
		
		const root = ReactDOM.createRoot(document.getElementById('root'));

		root.render(
			<NumberList numbers={numbers} />,
			document.getElementById('root')
		);
		=> 이 numberList 컴포넌트를 사용하면 numbers 배열의 숫자가 수십 개 또는 수백 개가 되어도 별도의 코드를 작성할 필요 없이 화면에 렌더링 할 수 있다
		그런데 이 코드를 실행해 보면 개발자 도구의 콘솔 탭에 경고 문구가 발생한다
		Warning:Each child in a list shuld have a unique "key" prop.
		리스트의 각 아이템은 무조건 고유한 키를 갖고 있어야 하기 때문에 발생하는 경고

31. List에서의 Key
	> Key는 list내 아이템을 구분하기 위한 고유한 문자열로, 어던 아이템이 변경, 추가 또는 제거되었는지 구분하기 위해 사용한다
	> 주민등록번호, 학번, 핸드폰번호, 여권번호 등 고유 번호들은 구분 지어진 특정 범위에서만 고유하면 된다
	> 리액트에서의 key 값도 같은 리스트에 있는 엘리먼트 사이에서만 고유한 값이면 ok

	> key로 값을 사용하는 경우
		const numbers = [1, 2, 3, 4, 5];
		cosnt listitems = numbers.map((number) =>
			<li key={number.toString()}>
				{number}
			</li>
		);
		
		~ numbers 배열의 숫자들이 중복되지 않은 경우에는 정상적으로 key의 역할을 하지만
		~ numbers 배열에 중복된 숫자가 있다면 key 값도 중복되기 때문에 고유성을 상실한다
		~ 그대로 실행 시에는 key 값이 중복된다는 경고 메세지가 출력된다

	> key로 id를 사용하는 경우
		const todoItems = todos.map((todo) => 
			<li key={todo.id}>
				{todo.text}
			</li>
		)
		
		~ id의 의미 자체가 고유한 값이라는 뜻이기 때문에 key 값으로 사용하기 적합
		~ 때문에 보통 id가 있으면 id 값을 key 값으로 사용한다

	> key로 index를 사용하는 경우
		const todoItems = todos.map((todo, index) =>
			<li key={index}>
				{todo.text}
			</li>
		);
		
		~ map() 함수에서 두 번째 파라미터롤 제공해주는 index 값을 key 값으로 사용한 방법
		~ index 값도 고유한 값이기 때문에 key 값으로 사용 가능
		~ 하지만 배열에서 아이템의 순서가 바뀔 수 있는 경우에는 key값으로 index를 사용하는 것을 권장하지 않는다. 성능에 부정적인 영향을 끼칠 수 있고, 컴포넌트의 state와 관련하여 문제를 일으킬 수도 있기 때문. 
		~ 따라서 index를 key값으로 사용하는 것은 아이템의 고유한 아이디가 없을 경우에만 사용!
		~ 참고. 리액트에서는 key를 명시적으로 넣어주지 않으면 기본적으로 이 index 값을 key 값으로 사용

	> map() 함수 안에 있는 Elements는 꼭 key가 필요하다!★

32. Forms
	> Form: 양식. 회원가입 하거나 로그인을 할 때 텍스트를 입력하는 양식을 볼 수 있는데, 텍스트 입력 뿐만 아니라 체크박스나 셀렉트 등 사용자가 무언가 선택을 해야 하는 것 모두가 Form.
	> 사용자로부터 입력을 받기 위해 사용하는 것

	> React에서의 Form과 HTML에서의 Form은 약간 차이가 있다.
	> React는 컴포넌트 내부에서 state를 통해 데이터를 관리
	> HTML Form은 엘리먼트 내부에 각각의 state가 존재

	> HTML Form
		<form>
			<label>
				이름:
				<input tyep="text" name="name" />
			</label>
			<button type="submit">제출</button>
		</form>

	- 사용자의 이름을 입력받고 제출하는 아주 간단한 코드
	- 리액트에서도 잘 작동하지만, 자바스크립트 코드를 통해 사용자가 입력한 값에 접근하기에는 불편한 구조
	- 자바스크립트 코드에서 사용자가 입력한 값이 접근하고 제어할 수 있어야 웹페이지를 개발할 때 더 편리
	- 그래서 리액트에서는 자바스크립트 코드로 사용자가 입력한 값에 접근하고 제어할 수 있도록 Controlled Component를 사용

	> Controlled Component : 값이 리액트의 통제를 받는 Input Form Element

		function NameForm(props) {
			const [value, setValue] = useState('');

			const handleChange = (event) => {
				setValue(event.target.value);
			};

			const handleSubmit = (event) => {
				alert('입력한 이름: ' + value);
				event.preventDefault();
			}

			return (
				<form onSubmit={handleSubmit}>
					<label>
						이름:
							<input type="text" value={value} onChange={handleChange} />
					</label>
					<button type="submit">제출</button>
				</form>
			);
		}

		~ 위의 HTML Form 코드를 React의 Controlled Component로 만든 것
		~ input 태그의 value 값은 React Component의 state에서 가져온다
		~ 또한 입력 값이 변경되었을 때 호출되는 onChange에는 handleChange() 함수가 호출되도록 했는데, HandleChange() 함수에서는 setValue 함수를 사용하여 새롭게 변경된 값을 value라는 이름의 state에 저장한다
		~ onChange의 콜백 함수의 첫 번째 파라미터인 event는 이벤트 객체를 나타내며, event.target은 현재 발생한 이벤트의 타겟을 가리킨다. event.target.value는 해당 타겟의 value 속성의 값을 뜻한다
		~ 즉, 여기에서 타겟은 input element가 되며, event.target.value는 input element의 값이 된다

	- Controlled Component를 사용하면 입력 값이 React 컴포넌트의 state를 통해 관리된다
	- 입력 양식의 초기 값을 내가 원하는 대로 넣어줄 수도 있으며, 다른 양식의 값이 변경되었을 때 또 다른 양식의 값도 자동으로 변경시킬 수 있음

	- 예제. 사용자가 입력한 모든 알파벳을 대문자로 변경시켜서 관리하고 싶을 때
		const handleChange = (event) => {
			setValue(event.target.value.toUpperCase());
		}
		=> handleChange() 함수로 들어오는 event의 target 값을 toUpperCase() 함수를 사용해 모두 대문자로 변경한 뒤 그 값을 state에 저장

		~ 이처럼 사용자의 입력을 직접적으로 제어 가능

33. 다양한 Forms
	> textarea 태그 : 여러 줄에 걸쳐 긴 텍스트를 입력받기 위한 HTML 태그
	- HTML textarea 태그
		<textarea>
			안녕하세요, 여기에 텍스트가 들어갑니다.
		</textarea>
		=> textarea 태그의 칠드런으로 텍스트가 들어가는 형태

	- React textarea 태그
		~ value라는 attribute를 사용하여 텍스트를 표시
		~ controlled Component 방식. 값을 컴포넌트의 state를 사용해서 다룰 수 있음

		// 고객으로부터 요청사항을 입력받기 위한 RequestForm 컴포넌트
		fucntion RequestForm(props) {
			// state로 value가 있고 이 값을 textarea 태그의 value라는 attribute에 넣어줌으로써 화면에 나타나게 된다
			// value를 선언할 때 default 값을 넣어줬기 때문에 처음 렌더링 될 때부터 textarea에 '요청사항을 입력하세요.'가 나타난다
			const [value, setValue] = useState('요청사항을 입력하세요.');

			const handleChange = (event) => {
				setValue(event.target.value);
			};

			const handleSubmit = (event) => {
				alert('입력한 요청사항: ' + value);
				event.prevetDefault();
			};

			return(
				<form onSubmit={handleSubmit}>
					<label>
						요청사항:
						<textarea value={value} onChange={handleChange} />
					</label>
					<button type="submit">제출</button>
				</form>
			);
		}

	> select 태그 : Drop-down 목록을 보여주기 위한 HTML 태그. Drop-down 목록은 여러가지 옵션 중에서 하나를 선택할 수 있는 기능을 제공

	- HTML select 태그
		<select>
			<option value="apple">사과</option>
			<option value="banana">바나나</option>
			<option selected value="grape">포도</option>
			<option value="watermelon">수박</option>
		</select>

	- React select 태그
		function FruitSelect(props) {
			// 'grape'를 초기값으로 가진 value가 state로 주어짐
			// 이 값이 select 태그의 value로 들어감
			const [value, setValue] = useState('grape');

			// 값이 변경될 경우, handleChange() 함수에서 setValue를 사용하여 값을 업데이트
			// 이 방식을 사용하면 사용자가 옵션을 선택했을 때 value라는 하나의 값만을 업데이트하면 되기 때문에 더 편리
			const handleChange = (event) => {
				setValue(event.target.value);
			};

			cosnt handleSubmit = (event) => {
				alert('선택한 과일: ' + value);
				event.preventDefault();
			};

			return(
				<form onSubmit={handleSubmit}>
					<label>
						과일을 선택하세요:
						<select value={value} onChange={handleChange}>
							<option value="apple">사과</option>
							<option value="banana">바나나</option>
							<option value="grape">포도</option>
							<option value="watermelon">수박</option>
						</select>
					</label>
					<button type="submit">제출</button>
				</form>
			);
		}

	- 만약 목록에서 다중으로 선택이 되도록 하려면 이 코드와 같이 multiple이라는 속성 값을 true로 하고, value로 선택된 옵션의 값이 들어있는 배열을 넣어준다

		<select multiple={true} value={['B', 'C']}>

	> file input 태그 : 디바이스의 저장 장치로부터 하나 또는 여러 개의 파일을 선택할 수 있게 해주는 HTML 태그

		<input type="file" />
	
	- 보통은 서버로 파일을 업로드하거나 자바스크립트의 File API를 사용해서 파일을 다룰 때 사용
	- file input 태그는 그 값이 읽기 전용이기 때문에, React에서는 Uncontrolled Component가 된다. 값이 React의 통제를 받지 않기 때문

	> Multiple Inputs
	- 하나의 컴포넌트에서 여러 개의 입력을 다루기 위해서는 여러 개의 state를 선언하여 각각의 입력에 대해 사용하면 된다

		// 호텔 예약을 위한 Reservation 컴포넌트
		// 예약을 위해 필요한 정보 두 가지를 입력받도록 되어 있음
		function Reservation(props) {
			// 각각의 state를 선언하고 각각의 set 함수를 통해 변경되는 값을 전달
			const [haveBreakfast, setHaveBreakfast]	= useState(true);
			const [numberOfGuest, setNumberOfGuest]	= useState(2);

			const handleSubmit = (event) => {
				alert(`아침식사 여부: ${haveBreakfast}, 방문객 수: ${numberOfGuest}`);
				event.preventDefault();
			};

			return (
				<form onSubmit={handleSubmit}>
					<label>
						아침식사 여부:
						<input
							type="checkbox"
							checked={haveBreakfast}
							onChange={(event) => {
								setHaveBreakfast(event.target.checked);
							}}
						/>
					</label>
					<br />
					<label>
						방문객 수:
						<input
							type="number"
							value={numberOfGuest}
							onChange={(event) => {
								setNumberOfGuest(event.target.value);
							}}	/>
					</label>
					<button type="submit">제출</button>
				</form>
			);
		}
	
	> Input Null Value
	- Controlled Component에 value prop을 정해진 값으로 넣으면 코드를 수정하지 않는 한 입력 값을 바꿀 수 없다
	- 만약 value prop은 넣되 자유롭게 입력할 수 있게 만들고 싶다면, 값에 undefined 또는 null을 넣어주면 된다

		// 18 이전 렌더링 방법
		ReactDOM.render(<input value="hi" />, rootNode);

		setTimeout(function() {
			ReactDOM.render(<input value={null} />, rootNode);
		}, 1000);
		=> 처음에는 input의 값이 "hi"로 정해져 있어 값을 바꿀 수 없는 입력 불가 상태였다가, 타이머에 의해 1초 뒤에 value가 null인 input 태그가 렌더링되면서 입력이 가능해진다

	- 이러한 방법을 잘 활용하면 value prop을 넣으면서 동시에 사용자가 자유롭게 입력하도록 만들 수 있다
