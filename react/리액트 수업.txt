리액트 수업

1. 개발환경 설정하기
Node.js(JavaScript runtime) , npm(node package manager) 설치하기
* npm은 프로젝트에서 필요로 하는 다양한 외부 라이브러리의 버전을 관리하고 편하게 설치 및 삭제할 수 있도록 도와주는 역할
* Node.js를 설치하면 npm은 자동으로 설치된다.

VSCode 사용



2. 리액스 소개
React: A JavaScript library for building user interfaces
사용자 인터페이스를 만들기 위한 JavaScript 라이브러리

라이브러리는 자주 사용되는 기능들을 정리해서 모아 놓은 것
+
사용자 인터페이스(User Interface, UI): 사용자와 컴퓨터 프로그램이 서로 상호작용을 하기 위해 중간에서 입력과 출력을 제어해주는 것
=> UI 라이브러리

리액트는 대표적은 JavaScript UI 라이브러리



3. 리액트 장점
- 빠른 업데이트와 렌더링 속도
	> Virtual DOM을 사용해 빠른 업데이트 속도를 제공한다. 
	> DOM은 웹페이지를 정의하는 오브젝트
	> 화면이 업데이트 된다는 것은 DOM이 수정된다는 말
	> Virtual DOM은 페이지에서 수정된 부분만을 찾아 빠르게 업데이트 해준다.
- Component-Based
	> 모든 페이지가 Component로 구성되어 있음
	> 레고 블록을 조립하듯 컴포넌트들을 모아 개발
	> 재사용성(Reusability) ↑
	   - 개발 기간이 단축됨
	   - 유지보수가 용이함(문제가 생긴 모듈만 재배포하면 됨)
- Meta의 오픈소스이므로 꾸준한 버전 업데이트가 이루어지고 발전해나가고 있다.
- 활발한 지식공유 & 커뮤니티
- React Native를 이용해 모바일 개발도 할 수 있다.
	


4. 리액트 단점
- 방대한 학습량
- 높은 상태관리 복잡도



5. 리액트로 웹사이트를 만들 때, create-react-app(cra)을 사용
- Node.js v14.0.0 이상
- npm v6.14.0 이상
- VSCode
- 사용법: npx create-react-app <your-project-name>
- 실제 사용 예제: npx create-react-app my-app
- 경로 변경(change directory): cd my-app
- 애플리케이션 실행: npm start > localhost:3000으로 웹페이지가 실행됨
- create-react-app 공식 링크 : https://reactjs.org/docs/create-a-new-react-app.html



6. jsx
A syntax extension to JavaScript: JavaScript의 확장 문법
JavaScript + XML/html
ex. const element = <h1>Hello, world!</h1>;
- jsx의 역할: 내부적으로 XML/html 코드를 작성하여도 최종적으로는 JavaScript로 변환해주는 역할
	React.createElement(
		type,
		[props],
		[...children]
	)
	> 리액트의 createElement() 함수가 그 역할을 한다

- 예제 1
	> jsx를 사용한 코드
	class Hello Extends Reacat.Component {
		render() {
			return <div>Hello {this.props.toWhat}</div>;
		}
	}
	ReactDOM.render(
		<Hello toWhat = "World"	/>
		document.getElementById('root');
	)
	> JavaScript와 html을 같이 사용한 jsx 코드로 짜여진 Hello라는 리액트 컴포넌트를 
	> ReactDOM의 render() 함수를 이용해 브라우저 화면에 렌더링 해줌 

	> jsx를 사용하지 않은 코드
	class Hello Extends Reacat.Component {
		render() {
			return React.createElement('div', null, `Hello ${this.props.toWhat}`);
		}
	}
	ReactDOM.render(
		React.createElement(Hello, { toWhat: 'World' }, null),
		document.getElementById('root');
	)

- 예제 2
	> jsx를 사용한 코드
	const element = (
		<h1 className="greeting">
			Hello, world!
		</h1>
	)

	> jsx를 사용하지 않은 코드
	const element = React.createElement(
		'h1',
		{ classname: 'greeting },
		'Hello, world!'
	)

	> 결과: React.createElement()의 결과로 아래와 같은 객체가 생성된다.
	> 리액트에서는 이 객체를 React element라고 부른다.
	const element = {
		type: 'h1',
		props: {
			classname: 'greeting',
			children: 'Hello, world!'
		}
	}

- 리액트에서 꼭 jsx를 사용해야 하는 것은 아니나, jsx를 사용하면 생산성과 가독성이 올라가기 때문에 권장됨
- jsx 장점: 1. 간결한 코드 / 2. 가독성 > 버그를 발견하기 쉬움 / 3. Infection Attacks 방어

- jsx 사용 방법: JavaScript + XML/html 이 섞인 형태이기 때문에 기본적으로 JS의 모든 문법이 지원됨
	> ...XML/html
	  {JavaScript 코드}
	  ...XML/html

	> 변수 사용
		const name = '소플';
		const element = <h1>안녕, {name}</h1>	<<<<
		ReactDOM.render(
			element,
			document.getElementById('root')
		)

	> 함수 사용
		function formatName(user) {
			return user.firstName + ' ' + user.lastName;
		}
		const user = {
			fristName: 'Inje',
			lastName: 'Lee'
		};
		const element = (
			<h1>
				Hello, {formatName(user)}	<<<<
			</h1>
		);
		ReactDOM.render(
			element,
			document.getElementById('root')
		);

	> html 태그 사이가 아닌 태그 속성(attribute)에 값을 넣고 싶을 때
		// 큰따옴표 사이에 문자열을 넣거나
		const element = <div tabIndex="0"></div>;
		// 중괄호 사이에 JavaScript 코드를 넣으면 됨!
		const element = <img src={user.avatarUrl}></img>;
	
	> jsx에서는 중괄호{} 사이에 무조건 JavaScript가 들어간다고 외워두면 좋다!

	> jsx를 이용하여 자식(children)을 정의하는 방법: html에서 작성하듯이 상위 태그가 하위 태그를 둘러싸면 자연스럽게 자식이 정의된다.
	  여기서 div 태그의 자식은 h1, h2 태그
		const element = (
			<div>
				<h1>안녕하세요</h1>	<<<<
				<h2>열심히 리액트를 공부해 봅시다!</h2>	<<<<
			</div>
		);



7. element: 어떤 물체를 구성하는 성분
   React Element: 리액트를 구성하는 성분 > Elements are the smallest building blocks of React apps
   element는 원래 DOM(웹페이지의 모든 구성 정보를 담고 있는 객체)에서 사용하던 용어
   개발자도구의 'Elements' 탭에서 볼 수 있는 element들은 DOM Elements이며, 우리가 브라우저 화면에서 실제로 볼 수 있는 html 요소를 나타낸다.

   JavaScript 개발 초창기에, 화면에 나타나는 내용을 기술하는 자바스크립트 객체가 필요했음
   그래서 처음에는 기술하다는 의미를 가진 Describe에서 파생된 Descriptor로 불림
   그러나 Descriptor가 최종적으로 나타나는 형태는 DOM Elements였기 때문에, DOM과의 통일성을 위해 element로 부르게 됨

   Virtual DOM의 element가 React Elements. 이것을 렌더링 하면 Browser DOM의 DOM Elements가 된다.
   결국 React Elements는 DOM Elements의 가상 표현이라고 볼 수 있다.
   또한 DOM Elements는 React Elements에 비해 많은 정보를 담고 있기 때문에 크고 무겁다.

   React Elements는 화면에서 보이는 것들을 기술하고, 이것을 바탕으로 우리에게 실제로 보이는 DOM Elements가 만들어진다.

   React Elements는 JavaScript 객체 형태로 존재
   > {
		type: 'button',
		props: {
			className: 'bg-green',
			children: {
				type: 'b',
				props: {
					children: 'Hello, element!'
				}
			}
		}
   	  }

	> <button class='bg-green'>
		<b>
			Hello, element!
		</b>
	  </button>

	> {
		type: Button,
		props: {
			color: 'green',
			children: 'Hello, element!'
		}
	  }

	> React.createElement{
		type,
		[props],
		[...children]
	  }

	> function Button(props) {
		return (
			<button classname={`bg-${props.color}`}>
				<b>
					{props.children}
				</b>
			</button>
		);
	  }

	  function ConfirmDialog(props) {
		return (
			<div>
				<p>내용을 확인하셨으면 확인 버튼을 눌러주세요.</p>
				<Button color='green'>확인</Button>
			</div>
		);
	  }

	> {
		type: 'div',
		props: {
			children: [
				{
					type: 'p',
					props: {
						children: '내용을 확인하셨으면 확인 버튼을 눌러주세요.'
					}
				},
				{
					type: Button,
					props: {
						color: 'green',
						children: '확인
					}
				}
			]
		}
	  }

	> {
		type: 'div',
		props: {
			children: [
				{
					type: 'p',
					props: {
						children: '내용을 확인하셨으면 확인 버튼을 눌러주세요.'
					}
				},
				{
					type: 'button',
					props: {
						className: 'bg-green',
						children: {
							type: 'b',
							props: {
								children: '확인'
							}
						}
					}
				}
			]
		}
	  }

